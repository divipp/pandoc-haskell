---
author:
- '*draft version 8*'
classoption: oneside
documentclass: book
geometry: 'margin=1.2in'
monofont: DejaVu Sans Mono
title: 'Pandoc''s Haskell'
urlcolor: blue
---

\defaultfontfeatures{Scale=MatchLowercase}
# Preface

## Goals of the tutorial

1.  reach intermediate level Haskell knowledge by guiding through the
    codebase of Pandoc
2.  become acquainted with the codebase of Pandoc

### Target audience

Basic Haskell knowledge is required; see [Basic Haskell language
constructs](#basic-haskell-language-constructs).

The tutorial aims to be self-contained.

## Introduction to Pandoc

[Pandoc](http://pandoc.org/) is a document converter which can convert
between several markup formats like Markdown and also support document
formats like HTML, PDF, docx and ODT.

According to [GitHub](https://github.com/search?q=language%3AHaskell)
and the [Debian Popularity
Contest](https://qa.debian.org/popcon-graph.php?packages=pandoc+ghc+darcs+xmonad+shellcheck+agda+haskell-stack&show_installed=on&want_percent=on&want_legend=on&from_date=2010-01-01&to_date=&hlght_date=&date_fmt=%25Y&beenhere=1),
Pandoc is the most popular Haskell application.

![Debian Popularity Contest trends for the most popular Haskell
packages](debian-popcon.png)

### Markdown basics

Markdown is designed to be easy to write and read.\
A simple example Markdown document is the following:

``` {.md}
Level-one header
================

First paragraph with a [link](/url) and *emphasis*.

Second paragraph with `verbatim text`.

    -- code block
    not True = False
    not False = True

Level-two header
----------------

- list item
- list item
  - sublist item
  - sublist item
```

Pandoc's Markdown supports a lot more constructs like subscripts,
superscripts, math formulas, ordered lists, tables, pictures, footnotes
and citations. The [User's Guide](https://pandoc.org/MANUAL.html) has
all the details.

The markdown source of this tutorial can be found
[here](https://github.com/divipp/pandoc-haskell).

### Command line interface of `pandoc`

By default `pandoc` works as a pipe:

``` {.bash}
$ echo 'Hello, *World*!' | pandoc
<p>Hello, <em>World</em>!</p>
```

The target language can be changed with the `--to` option (the default
is `html`):

``` {.bash}
$ echo 'Hello, *World*!' | pandoc --to latex
Hello, \emph{World}!
```

The source language can be changed with the `--from` option (the default
is `markdown`):

``` {.bash}
$ echo '<p>Hello, <em>World</em>!</p>' | pandoc --from html --to markdown
Hello, *World*!
```

Language extensions can be turned on and off individually (some of them
are turned on by default):

\setmonofont{DejaVu Sans}
``` {.bash}
$ echo ':smile: H~2~O' | pandoc --from markdown
<p>:smile: H<sub>2</sub>O</p>
```

<!-- -->
``` {.bash}
$ echo ':smile: H~2~O' | pandoc --from markdown+emoji
<p>ðŸ˜„ H<sub>2</sub>O</p>
```

<!-- -->
``` {.bash}
$ echo ':smile: H~2~O' | pandoc --from markdown+emoji-subscript
<p>ðŸ˜„ H~2~O</p>
```

\setmonofont{DejaVu Sans Mono}
Pandoc can be invoked with input and output files. The source and target
language is guessed by the file extensions when it is not given
explicitly.

``` {.bash}
$ pandoc inputfile.md -o outputfile.html
```

Multiple input files are concatenated by `pandoc`:

``` {.bash}
$ pandoc chap1.md chap2.md chap3.md
```

Instead of an input file, an absolute URI may be given.\
For example, BBC news headlines can be read without styling by

``` {.bash}
$ pandoc http://www.bbc.com/news --from html-native_divs-native_spans \
--to markdown-header_attributes --reference-links | less
```

### Standalone documents

By default, `pandoc` produces a fragment in the output format.\
For example, the following command produce a fragment of a linux manual
page:

``` {.bash}
$ echo 'Hello, *World*!' | pandoc --to=man
.PP
Hello, \f[I]World\f[]!
```

To produce a standalone document, one should add the `--standalone` or
`-s` option:

``` {.bash}
$ echo 'Hello, *World*!' | pandoc --to=man -s
.\" Automatically generated by Pandoc 2.1.3
.\"
.TH "" "" "" "" ""
.hy
.PP
Hello, \f[I]World\f[]!
```

Standalone documents contain metadata like title, author and date which
can be set with the `--metadata` or `-M` option:

``` {.bash}
$ echo 'Hello, *World*!' | \
pandoc --to=man -s -M title:Hello -M author:'PÃ©ter DiviÃ¡nszky' -M date:07.04.2018
.\" Automatically generated by Pandoc 2.1.3
.\"
.TH "Hello" "" "07.04.2018" "" ""
.hy
.PP
Hello, \f[I]World\f[]!
.SH AUTHORS
PÃ©ter DiviÃ¡nszky.
```

Metadata can be parsed from a separate file.\
Suppose that `metadata.yaml` contains

``` {.yaml}
---
title: Hello
author:
- PÃ©ter DiviÃ¡nszky
date: 07.04.2018
---
```

then one can invoke `pandoc` like

``` {.bash}
$ pandoc metadata.yaml content.md
```

The content of the metadata file can be included directly in the
Markdown source file.

Table of contents can be generated with `--toc`.\
Sections can be numbered with `--number-sections`.

The language can be set like `--variable=lang:hu`.

Several output formats allow other useful options like `--css` and
`--self-contained` for HTML output.

# Basic Haskell language constructs

This section is a revision of the required Haskell knowledge rather than
a full-blown Haskell introduction. Skim through this section to note in
which areas need you more preparation for the rest of the tutorial.

## Lexical structure of Haskell modules

### Comments

    x = 1  -- comment begins with two dashes, lasts until the end of the line
    y = 2
    ------------------------ comment with more dashes -------------------------

<!-- -->
    {-
    multi-line
    comments {- may be nested -}
    -}

### Layout

Layout of Haskell code matters:

    f x
    = x         -- *wrong*

<!-- -->
    f x
     = x        -- *right*

Only the *indentation* of code lines matters, other whitespace does not
matter.

Example:

    module Main where   -- 'where' starts a new block
    f x = y  where      -- 'where' starts another block
        y = z
        z =
            x
    w = f 4

This is the same as:

    module Main where {
    f x = y  where { y = z; z = x; };
    w = f 4;
    }

Keywords which start a new block: `where`, `of` and `do`.

### Literals

Note: There are no negative number literals, see [negation
syntax](#negation-syntax).

    109                     -- a decimal integral
    0o155, 0O155            -- the same octal integrals
    0x6d, 0x6D, 0X6d, 0X6D  -- the same hexadecimal integrals

<!-- -->
    0.314                   -- decimal fractional
    3.14e-1, 3.14E-1        -- the same decimal fractionals in scientific notation

<!-- -->
    'a', 'Ã¡', 'A', '1'      -- some alphanumeric characters
    '+', '!', '&'           -- some symbol characters
    '\''                    -- the single quote character
    '\\'                    -- the backslash character
    '\n', '\LF'             -- the line feed character
    '\225'                  -- the 'Ã¡' character with decimal unicode code
    '\xE1'                  -- the 'Ã¡' character with hexadecimal unicode code
    '\o341'                 -- the 'Ã¡' character with octal unicode code

<!-- -->
    ""                      -- the empty string
    "aÃ¡\225\\\'\""          -- a non-empty string
    "\225\&9"               -- same as "Ã¡9"
    "multi-line \
       \string"             -- same as "multi-line string"

### Identifiers

#### Operator identifiers

operator:
:   string of `!?.#$%@&*+-~^/|\<=>` characters or non-ASCII unicode
    symbols\
    exceptions: `--`, `::`, `->`, `<-`, `=>`, `=`, `~`, `\`, `|`

alphanumeric identifiers:
:   string of alphanumeric characters or `_'`, beginning with a letter
    or `_`\
    exceptions: `_`, `module`, `where`, `import`, `qualified`, `as`,
    `hiding`, `data`, `type`, `newtype`, `deriving`, `class`,
    `instance`, `default`, `infix`, `infixl`, `infixr`, `let`, `in`,
    `case`, `of`, `if`, `then`, `else`, `do`

Examples:

    f' :: Int -> [Int]
    f' x = x + 1 : x * 2 : []
    -- operators: +, :, *
    -- alphanumeric identifiers: f', x, Int

The distinction between operators and alphanumeric identifiers matters
only syntactically, see [application syntax](#application-syntax).

#### Variable vs.Â constructor identifiers

constructor:
:   identifier beginning with an uppercase letter or `:` (colon).

variable:
:   any other identifier

Lexically, *function names* and *function parameters* are variables.

Examples:

    f' :: Int -> [Int]
    f' x = x + 1 : x * 2 : []
    -- variables: f', x, +, *
    -- constructors: Int, :

The distinction between variables and constructors matters in pattern
matching (in expressions) and quantification (in types).

#### Expression vs.Â type namespace

There are two namespaces in Haskell:

expression namespace
:   is the default and also comes after keyword `where`

type namespace
:   comes after keywords `::`, `data`, `type`, `newtype`, `class`,
    `instance`

For example, `x` in the following code has two different uses: `x` as a
type variable and `x` as an (expression) variable.

    swap :: (x, y) -> (y, x)     -- (expression) variable: swap; type variables: x, y
    swap (x, y) = (y, x)         -- (expression) variables: swap, x, y

#### Qualified names

Any identifier can be qualified by prefixing it with one or more
qualifier:

    Prelude.id
    Data.Map.toList
    Data.Monoid.<>      -- qualified operator

The meaning of qualifiers is discussed in [Import lists](#import-list).

#### Special syntax for some frequently used constructors

The following constructors are not identifiers lexically but can be
considered as identifiers with special syntax. See [tuple and list
syntax](#tuple-and-list-syntax) and [compound types](#compound-type):

    (->)   -- function type constructor
    []     -- empty list constructor (as an expression) / list type constructor (as a type)
    ()     -- unit constructor / type constructor
    (,)    -- 2-tuple constructor / type constructor
    (,,)   -- 3-tuple constructor / type constructor
    ...

## Expressions

### Application syntax

Prefix notation for alphanumeric identifiers:

    id 2                        -- id applied to 2
    div x y                     -- div applied to x and y
    Either Int Bool             -- Either applied to Int and Bool
    Prelude.Either Int Bool     -- how to apply a qualified name

Prefix notation for operators:

    (:) 1 []                    -- (:) applied to 1 and []
    (++) xs ys                  -- (++) applied to xs and ys
    (Prelude.++) xs ys          -- how to apply a qualified operator

Expressions with infix notation:

    x `div` y                   -- same as  div x y
    Int `Either` Bool           -- same as  Either Int Bool
    Int `Prelude.Either` Bool   -- same as  Prelude.Either Int Bool
    1 : []                      -- same as  (:) 1 []
    xs ++ ys                    -- same as  (++) xs ys
    xs Prelude.++ ys            -- same as  (Prelude.++) xs ys

#### Precedences -- order of applications

    f x + y     -- same as ((f x) + y), prefix application is stronger than infix application
    x + y * z   -- same as (x + (y * z)), because (*) is stronger than (+)
    x + y + z   -- same as ((x + y) + z), because (+) is left-associative

Precedences are declared with [fixity
declarations](#fixity-declaration).

Note that prefix application is left-associative:

    replicate 4 'c'     -- same as ((replicate 4) 'c')
                        -- replicate 4 :: a -> [a]

#### Negation syntax

Negation is the only prefix operation:

    -1          -- negated 1 (not a literal)
    - 1         -- the same negated 1; whitespace does not matter
    -x          -- negated x

Negation `-` is parsed as if it was `0-` :

    -x+2        -- same as  0-x+2 = (0-x)+2 = (-x)+2
    -x^2        -- same as  0-x^2 = 0-(x^2) = -(x^2)

Negation needs parenthesis in several cases:

    x - (- 2)   -- cannot be written as  x - - 2
    x - (-2)    -- the same, cannot be written as  x - -2

#### Partial application

A function/constructor is partially applied if it is applied to less
arguments than its arity. The *arity* of a function/constructor is
determined by its definition (see later).

    (+) 1       -- same as \x -> (+) 1 x, see lambda expression
    map f       -- same as \xs -> map f xs

#### Overapplication

A function is overapplied if it is applied to more arguments than its
arity.

    head [sin, cos] 1  -- same as (head [sin, cos]) 1

Overapplying a constructor yields always a type error.

### Lambda expression

    \x -> x + 1         -- \pattern -> expression

<!-- -->
    \x y -> x + 2*y     -- same as  \x -> \y -> x + 2*y

### Section

Left sections:

    (+1)                -- same as  \x -> x + 1
    (+ 2*a)             -- same as  \x -> x + 2*a

Right sections:

    (2^)                -- same as  \n -> 2^n
    (f 2 ^)             -- same as  \n -> f 2 ^ n

### Tuple and list syntax

Tuple and list construction has special syntax:

    ('c', 3)            -- same as  (,) 'c' 3
    (1, "hello", True)  -- same as  (,,) 1 "hello" True

<!-- -->
    []                  -- empty list
    [1,2,3]             -- same as  1 : 2 : 3 : []

Dot-dot expressions are just syntactic sugars:

    [0..]               -- same as  enumFrom 0
    [0..10]             -- same as  enumFromTo 0 10
    [0,2..]             -- same as  enumFromThen 0 2
    [0,2..10]           -- same as  enumFromThenTo 0 2 10

<!-- -->
    ['a'..'z']          -- another use case for enumFromTo

#### List comprehension syntax

    [2^n | n <- [0..10]]          -- one generator
    [2^n | n <- reverse xs]       -- the generator can refer to any list
    [2^n | n <- [0..10], even n]  -- one generator, one boolean guard
    [2^n | even n]                -- one boolean guard (the result is empty or singleton)
    [(a, b) | a <- [0..10], b <- [a..10]]    -- two generators
    [x | n <- [0..], let x = 2^n, x > 10^9]  -- generator, local declaration, boolean guard
    ...

### Type annotation

    1 :: Int            -- expression :: type
    f 1 :: Int          -- same as  (f 1) :: Int
    g (1 :: Int)

### If expression

    if a < b then a else b       -- if expression then expression else expression

### Case expression

    case as of              --  case expression of
       [] -> True           --     pattern -> expression
       x: xs -> odd x       --     pattern -> expression

Case alternatives can also have [guards](#guard) and [local
definitions](#where-block).

## Patterns

The meaning of a pattern is given if we know what expressions are
*matched* by the pattern and which variables are *bound* to which
expressions by a successful match.

### Variable pattern

    v           -- matches everything, binds variable v to the matched expression

Each variable can be bound only once:

    f x x = 3   -- *wrong*, x is bound twice

If the variable is not used, it can be prefixed with an underscore:

    _v          -- matches everything, binds variable _v to the matched expression
                -- but no warning is given if _v is not used

Wildcard can be seen as a special case:

    _           -- matches everything, binds nothing

<!-- -->
    f _ _ = 3   -- ok, no multiple binding

### Literal pattern

Literals can be used in patters, with negation too:

    f (-1) = 1     -- matches (-1)
    f x    = x

### Constructor pattern

`Bool`, tuple and list patterns has similar syntax as the corresponding
expressions:

    (True, _:_)         -- same as  ((,) True ((:) _ _))
    []                  -- empty list pattern
    [a, True, _]        -- same as  (a : True : _ : [])

### Application in patterns

Patterns have more restriction on application than expressions:

    not True     -- *wrong pattern*, only constructor application is allowed in patterns
    (:) True     -- *wrong pattern*, partial application is not allowed in patterns

Overapplication of constructors are always wrong:

    (:) a b c    -- *wrong pattern*, *wrong expression*

### At-pattern

With an at-pattern one can match a pattern and bind a variable to the
whole expression at the same time:

              -- variable @ pattern
    v@(_:t)   -- matches non-empty lists, binds v to the whole list and t to the the tail

## Types

### Simple type

    Char
    Bool

### Compound type

    Maybe Int

Compound list and tuple types have special syntax:

    (Int, Char)    -- same as  (,) Int Char
    [Int]          -- same as  [] Int

#### Function type

    Bool -> Bool               -- same as   (->) Bool Bool
    Bool -> Bool -> Bool       -- same as   Bool -> (Bool -> Bool)

### Type variables

    a -> b -> a
    (a, [a])        -- possible representation of non-empty lists of a-s

Undefined type variables are implicitly forall-quantified at the
beginning of the type.

    id :: a -> a                  -- id can be used for any type

### Type class constraints

    Num a => a                    -- constraint => type
    Num Int => a                  -- same as  a, because there is  instance Num Int
    Num Char => a                 -- yields no  instance Num Char  found error
    Eq [a] => b                   -- same as  Eq a => b, because  Eq a => Eq [a]

Multiple constraints:

    (Num a, Show a) => a -> a     -- same as  (Show a, Num a) => a -> a
    (Eq a, Ord a) => b            -- same as  Ord a => b, because  Eq a => Ord a

## Declarations

### Function definition

    double x = 2 * x        -- one argument

<!-- -->
    add3 x y z = x + y + z  -- 3 arguments

#### Operator definition

    a *+ b = a * b + b          -- same as   (*+) a b = a * b + b

<!-- -->
    (f . g) x = f (g x)         -- same as   (.) f g x = f (g x)

<!-- -->
    a `diff` b = abs (a - b)    -- same as   diff a b = abs (a - b)

#### Function alternatives

    not True  = False    -- 1st alternative
    not False = True     -- 2nd alternative

<!-- -->
#### Guards

    min x y
        | x <= y    =  x
        | otherwise =  y        -- otherwise = True

#### Where block

    f . g = h
      where
        h x = f (g x)

#### Recursive function

    nub [] = []
    nub (x: xs) = x: nub [a | a <- xs, a /= x]

Mutual recursion:

    evenLength [] = True
    evenLength (_: xs) = oddLength xs

    oddLength [] = False
    oddLength (_: xs) = evenLength xs

### Constant definition

    c = 1 + 4

<!-- -->
    [one, two, three, four, five] = [1..5]    -- five constants defined

Constant definition used in a where block:

    distribute []      = ([], [])
    distribute (x: xs) = (x: odds, evens)
      where
        (evens, odds) = distribute xs          -- defines evens and odds

#### Recursive constant

    cycle xs = ys
      where
        ys = xs ++ ys       -- recursive constant

Mutual recursion:

    falseTrue = False: trueFalse
    trueFalse = True:  falseTrue

#### Ad-hoc polymorph constant

    one :: Num a => a
    one = 1

### Type annotation

    one :: Int          -- variable(s) :: type

<!-- -->
    two, three :: Int   -- same as 'two :: Int' and 'three :: Int'

Each type annotation should have a corresponding definition.

# Basic Haskell declarations

## Numbers

*Entities in this section are defined in `Prelude` and `Data.Complex`.*

#### Types {#types-1 .unnumbered}

    Int             --- integer modulo 2^64 (or 2^32)
    Integer         --- integer
    Rational        --- ratio of two integers
    Float           --- single precision floating point number
    Double          --- double precision floating point number
    Complex Float   --- complex numbers built on Float
    Complex Double  --- complex numbers built on Double

#### Type classes {#type-classes .unnumbered}

    Num        =  {Int, Integer, Rational, Float, Double, Complex Float, Complex Double, ...}
    Real       =  {Int, Integer, Rational, Float, Double, ...}
    Integral   =  {Int, Integer, ...}
    Fractional =                {Rational, Float, Double, Complex Float, Complex Double, ...}
    RealFrac   =                {Rational, Float, Double, ...}
    Floating   =                          {Float, Double, Complex Float, Complex Double, ...}
    RealFloat  =                          {Float, Double, ...}

![Type class hierarchy](NumClasses.pdf){width="40%"}

#### Constants {#constants .unnumbered}

    pi :: Floating a => a    --- Ï€ = 3.14..

#### Conversions {#conversions .unnumbered}

    fromIntegral :: (Num b, Integral a) => a -> b       --- integer to any number type
    realToFrac   :: (Fractional b, Real a) => a -> b    --- real to fractional

#### Rounding {#rounding .unnumbered}

    truncate :: (Integral b, RealFrac a) => a -> b    --- round towards zero
    round    :: (Integral b, RealFrac a) => a -> b    --- round towards nearest
    ceiling  :: (Integral b, RealFrac a) => a -> b    --- round up
    floor    :: (Integral b, RealFrac a) => a -> b    --- round down

#### Operators {#operators .unnumbered}

    (+)    :: Num a => a -> a -> a    --- addition
    (*)    :: Num a => a -> a -> a    --- multiplication
    (-)    :: Num a => a -> a -> a    --- subtraction
    negate :: Num a => a -> a      --- negation, can be used with prefix operator '-'
    (/)    :: Fractional a =>  a -> a -> a    --- division
    (^)    :: (Num a, Integral b) =>        a -> b -> a    --- non-negative exponent
    (^^)   :: (Integral b, Fractional a) => a -> b -> a    --- integer exponent
    (**)   :: Floating a =>                 a -> a -> a    --- floating exponent

#### Functions {#functions .unnumbered}

    abs   ::      Num a => a -> a       --- absolute value
    sqrt  :: Floating a => a -> a       --- square root
    log   :: Floating a => a -> a       --- logarithm to the base of e
    exp   :: Floating a => a -> a       --- base e exponential function
    sin   :: Floating a => a -> a       --- sine of argument in radians
    cos   :: Floating a => a -> a       --- cosine of argument in radians
    tan   :: Floating a => a -> a       --- tangent of argument in radians
    asin  :: Floating a => a -> a       --- arcsine
    acos  :: Floating a => a -> a       --- arccosine
    atan  :: Floating a => a -> a       --- arctangent
    sinh  :: Floating a => a -> a       --- hyperbolic sine
    cosh  :: Floating a => a -> a       --- hyperbolic cosine
    tanh  :: Floating a => a -> a       --- hyperbolic tangent
    asinh :: Floating a => a -> a       --- hyperbolic arcsine
    acosh :: Floating a => a -> a       --- hyperbolic arccosine
    atanh :: Floating a => a -> a       --- hyperbolic arctangent
    quot  :: Integral a => a -> a -> a  --- quotient (multiplicative)
    div   :: Integral a => a -> a -> a  --- quotient (additive)
    rem   :: Integral a => a -> a -> a  --- remainder (multiplicative)
    mod   :: Integral a => a -> a -> a  --- remainder (additive)
    gcd   :: Integral a => a -> a -> a  --- greatest common divisor

## Booleans and comparison

*Entities in this section are defined in `Prelude`.*

#### Types {#types-2 .unnumbered}

    Bool         --- boolean value
    Ordering     --- result of comparison

#### Type classes {#type-classes-1 .unnumbered}

There are `Eq` and `Ord` instances for almost every type but functions.

    Eq   = {Int, Double, Char, (Int, Char), [Int], ([Int], Char), [[Int]], ...}
    Ord  = {Int, Double, Char, (Int, Char), [Int], ([Int], Char), [[Int]], ...}

#### Constructors {#constructors .unnumbered}

    False     :: Bool       --- false
    True      :: Bool       --- true
    GT        :: Ordering   --- greater
    LT        :: Ordering   --- less
    EQ        :: Ordering   --- equal

#### Constants {#constants-1 .unnumbered}

    otherwise :: Bool       --- same as True

#### Logical connectives {#logical-connectives .unnumbered}

    (&&) :: Bool -> Bool -> Bool    --- logical and
    (||) :: Bool -> Bool -> Bool    --- logical or
    not  :: Bool -> Bool            --- logical negation

#### Operators {#operators-1 .unnumbered}

    (==) :: Eq a  => a -> a -> Bool    --- equal
    (/=) :: Eq a  => a -> a -> Bool    --- not equal
    (<)  :: Ord a => a -> a -> Bool    --- less
    (>)  :: Ord a => a -> a -> Bool    --- greater
    (<=) :: Ord a => a -> a -> Bool    --- less or equal
    (>=) :: Ord a => a -> a -> Bool    --- greater or equal

#### Functions {#functions-1 .unnumbered}

    compare :: Ord a => a -> a -> Ordering    --- compare two elements
    even :: Integral a => a -> Bool     --- True if even
    odd  :: Integral a => a -> Bool     --- True if odd
    min  :: Ord a => a -> a -> a        --- minimum of two elements
    max  :: Ord a => a -> a -> a        --- maximum of two elements

## Tuples

*Entities in this section are defined in `Prelude`.*

#### Types (`a`, `b`, `c` and `d` are arbitrary types) {#types-a-b-c-and-d-are-arbitrary-types .unnumbered}

    (a, b)            --- ordered pair (2-tuple)
    (a, b, c)         --- ordered triple (3-tuple)
    (a, b, c, d)      --- 4-tuple
    ...

#### Constructors {#constructors-1 .unnumbered}

    (,)   :: a -> b -> (a, b)                   --- ordered pair (2-tuple) constructor
    (,,)  :: a -> b -> c -> (a, b, c)           --- ordered triple (3-tuple) constructor
    (,,,) :: a -> b -> c -> d -> (a, b, c, d)   --- 4-tuple constructor
    ...

#### Functions {#functions-2 .unnumbered}

    fst :: (a, b) -> a    --- first element
    snd :: (a, b) -> b    --- second element

## Lists

*Entities in this section are defined in `Prelude` or `Data.List`.*

Notes

-   In case of `Foldable t`, replace `t` with the list type constructor.
    For example,

        concat :: [[a]] -> [a]

#### Type {#type .unnumbered}

    [a]     --- a-list (a is an arbitrary type)

#### Constructors {#constructors-2 .unnumbered}

    []      :: [a]                  --- empty list
    (:)     :: a -> [a] -> [a]      --- insert into left end (beginning) of a list

#### Generic functions {#generic-functions .unnumbered}

    (++)    :: [a] -> [a] -> [a]    --- concatenate two lists
    concat  :: Foldable t => t [a] -> [a]    --- concatenate many lists
    reverse :: [a] -> [a]           --- reverse order of elements
    head    :: [a] -> a             --- first element of a list
    last    :: [a] -> a             --- last element of a list
    init    :: [a] -> [a]           --- all element but the last
    tail    :: [a] -> [a]           --- all element but the first
    inits   :: [a] -> [[a]]         --- iterated init
    tails   :: [a] -> [[a]]         --- iterated tail
    repeat  :: a -> [a]             --- repeat element infinitely

#### Functions with `Int`{.unnumbered}

    (!!)      :: [a] -> Int -> a          --- element indexed by 0, 1, 2, ...
    length    :: [a] -> Int               --- length of a list
    take      :: Int -> [a] -> [a]        --- take first n element of a list
    drop      :: Int -> [a] -> [a]        --- drop first n element of a list
    splitAt   :: Int -> [a] -> ([a], [a]) --- take and drop together
    replicate :: Int -> a -> [a]          --- repeat an element n times

#### Functions with `Bool`{.unnumbered}

    null :: Foldable t => t a -> Bool       --- True if there is no element
    and  :: Foldable t => t Bool -> Bool    --- logical and for more values
    or   :: Foldable t => t Bool -> Bool    --- logical or for more values

#### Functions with numbers {#functions-with-numbers .unnumbered}

    sum     :: (Num a, Foldable t) => t a -> a    --- sum of elements
    product :: (Num a, Foldable t) => t a -> a    --- product of elements

#### Functions with tuples {#functions-with-tuples .unnumbered}

    zip   :: [a] -> [b] -> [(a, b)]    --- pairing of list elements (zipping)
    unzip :: [(a, b)] -> ([a], [b])    --- unzipping of list of pairs

#### Functions with `Eq`{.unnumbered}

    elem       :: (Eq a, Foldable t) => a -> t a -> Bool    --- is the element in the list?
    delete     :: Eq a => a -> [a] -> [a]     --- delete first occurrence of element
    nub        :: Eq a => [a] -> [a]          --- delete repeating elements
    group      :: Eq a => [a] -> [[a]]        --- group equal attached elements
    isPrefixOf :: Eq a => [a] -> [a] -> Bool  --- True if second list starts with first list

#### Functions with `Ord`{.unnumbered}

    minimum :: (Ord a, Foldable t) => t a -> a    --- minimum element
    maximum :: (Ord a, Foldable t) => t a -> a    --- maximum element
    insert  :: Ord a => a -> [a] -> [a]           --- insert element into sorted list
    sort    :: Ord a => [a] -> [a]                --- sort list (increasing order)

## Characters

*Entities in this section are defined in `Prelude` or `Data.Char`.*

#### Type {#type-1 .unnumbered}

    Char    --- unicode characters

#### Functions {#functions-3 .unnumbered}

    ord        :: Char -> Int    --- unicode code
    chr        :: Int -> Char    --- character of given unicode code
    isSpace    :: Char -> Bool   --- True for ' ', '\t', '\n', ...
    isDigit    :: Char -> Bool   --- True for '1', '2', ...
    isAlpha    :: Char -> Bool   --- True for 'a', 'A', ...
    isUpper    :: Char -> Bool   --- True for 'A', 'B', ...
    isLower    :: Char -> Bool   --- True for 'a', 'b', ...
    toUpper    :: Char -> Char   --- toUpper 'a' == 'A'
    toLower    :: Char -> Char   --- toLower 'A' == 'a'
    digitToInt :: Char -> Int    --- digitToInt '3' == 3
    intToDigit :: Int -> Char    --- intToDigit 3 == '3'

## Strings

*Entities in this section are defined in `Prelude`.*

#### Type {#type-2 .unnumbered}

    String         --- type String = [Char]

#### Type class {#type-class .unnumbered}

There are `Show` and `Read` instances for almost every type but
functions.

    Show  = {Int, Double, Char, (Int, Char), [Int], ([Int], Char), [[Int]], ...}
    Read  = {Int, Double, Char, (Int, Char), [Int], ([Int], Char), [[Int]], ...}

#### Functions {#functions-4 .unnumbered}

    show    :: Show a => a -> String    --- convert to string
    read    :: Read a => String -> a
    lines   :: String -> [String]    --- split string by newlines
    unlines :: [String] -> String    --- concatenate strings with newlines
    words   :: String -> [String]    --- split string by spaces
    unwords :: [String] -> String    --- concatenate strings with whitespaces

## Enumerations

*Entities in this section are defined in `Prelude`.*

#### Type class {#type-class-1 .unnumbered}

    Enum = {Int, Integer, Rational, Float, Double, Char, Bool, ...}

#### Dot-dot expressions: lists made by arithmetic sequences {#dot-dot-expressions-lists-made-by-arithmetic-sequences .unnumbered}

    enumFrom       :: Enum a => a -> [a]             --- difference = 1
    enumFromTo     :: Enum a => a -> a -> [a]        --- difference = 1, with upper bound
    enumFromThen   :: Enum a => a -> a -> [a]        --- 
    enumFromThenTo :: Enum a => a -> a -> a -> [a]   --- with upper bound

#### Syntax {#syntax .unnumbered}

    [1..]      = enumFrom 1
    [1..100]   = enumFromTo 1 100
    [1,3..]    = enumFromThen 1 3
    [1,3..100] = enumFromThenTo 1 3 100

#### Conversions {#conversions-1 .unnumbered}

    fromEnum :: Enum a => a -> Int    --- index
    toEnum   :: Enum a => Int -> a    --- inverse of fromEnum

## Higher-order functions

*Entities in this section are defined in `Prelude` or `Data.Function`.*

    id      :: a -> a                           --- id "anything" == "anything"
    const   :: a -> b -> a                      --- const 3 "True" == 3
    ($)     :: (a -> b) -> a -> b               --- (even $ 1+2) == False
    (.)     :: (b -> c) -> (a -> b) -> a -> c   --- (even . (+1)) 2 == False
    uncurry :: (a -> b -> c) -> (a, b) -> c     --- uncurry mod (5,2) == 1
    curry   :: ((a, b) -> c) -> a -> b -> c     --- inverse of uncurry
    flip    :: (a -> b -> c) -> b -> a -> c     --- flip (**) 3 4 == 64.0
    on      :: (b -> b -> c) -> (a -> b) -> a -> a -> c   --- ((==) 'on' even) 2 10 == True
    until   :: (a -> Bool) -> (a -> a) -> a -> a          --- until (> 10) (+ 1) 3 == 11

#### Functions with lists {#functions-with-lists .unnumbered}

    map       :: (a -> b) -> [a] -> [b]         --- map (^2) [1..4] == [1,4,9,16]
    iterate   :: (a -> a) -> a -> [a]           --- iterate (+2) 2 == [2,4..]
    filter    :: (a -> Bool) -> [a] -> [a]      --- filter (<3) [1..100] == [1,2]
    partition :: (a -> Bool) -> [a] -> ([a], [a])    --- partition odd [1..5] == ([1,3,5],[2,4])
    takeWhile :: (a -> Bool) -> [a] -> [a]      --- takeWhile (<3) (cycle [1..5]) == [1,2]
    dropWhile :: (a -> Bool) -> [a] -> [a]      --- dropWhile (<3) [1..5] == [3,4,5]
    span      :: (a -> Bool) -> [a] -> ([a], [a])    --- span (<3) [1..5] == ([1,2],[3,4,5])
    any :: Foldable t => (a -> Bool) -> t a -> Bool  --- any (<3) [1,2,4] == True
    all :: Foldable t => (a -> Bool) -> t a -> Bool  --- all (<3) [1,2,4] == False

#### Generalized functions {#generalized-functions .unnumbered}

    zipWith   :: (a -> b -> c) -> [a] -> [b] -> [c]      --- zipWith (+) [2,3] [2,2] == [4,5]
    groupBy   :: (a -> a -> Bool) -> [a] -> [[a]]        --- groupBy (\x y -> odd x && odd y) [1,3,4,5]
    sortBy    :: (a -> a -> Ordering) -> [a] -> [a]      --- sort by ordering
    maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a    --- maximum by ordering
    minimumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a    --- minimum by ordering

#### Folds {#folds .unnumbered}

    foldl1 :: Foldable t => (a -> a -> a) -> t a -> a        --- foldl1 (**) [2,3,4] == 4096.0
    scanl1 ::               (a -> a -> a) -> [a] -> [a]      --- scanl1 (^) [2,3,4] == [2,8,4096]
    foldr1 :: Foldable t => (a -> a -> a) -> t a -> a        --- fold from right
    scanr1 ::               (a -> a -> a) -> [a] -> [a]      ---   with intermediate values
    foldl  :: Foldable t => (b -> a -> b) -> b -> t a -> b   --- foldl (+) 5 [2,3,4] == 14
    foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b   --- strict foldl
    scanl  ::               (b -> a -> b) -> b -> [a] -> [b] --- scanl1 with initial value
    foldr  :: Foldable t => (a -> b -> b) -> b -> t a -> b   --- foldr1 with initial value
    scanr  ::               (a -> b -> b) -> b -> [a] -> [b] --- scanr1 with initial value

## Error handling

*Entities in this section are defined in `Prelude`.*

    undefined :: a          --- abort evaluation
    error :: String -> a    --- abort evaluation with error message

## Fixity declarations in `Prelude`

    infixr 9  !!, .
    infixr 8  ^, ^^, **
    infixl 7  *, /, `rem`, `mod`, `div`, `quot`
    infixl 6  -, +
    infixr 5  :, ++
    infix  4  ==, /=, <, >, <=, >=
    infixr 3  &&
    infixr 2  ||
    infixr 0  $

## Type class hierarchy in `Prelude`

    class                              Show a
    class                              Read a
    class                              Enum a
    class                              Eq a
    class                     Eq a =>  Ord a
    class                              Num a
    class                    Num a =>  Fractional a
    class             Fractional a =>  Floating a
    class           (Num a, Ord a) =>  Real a
    class         (Real a, Enum a) =>  Integral a
    class   (Real a, Fractional a) =>  RealFrac a
    class (RealFrac a, Floating a) =>  RealFloat a

![Type class hierarchy](Classes.pdf){width="40%"}

Explanation: `Eq` contains `Ord`, i.e.Â if there is an `Ord` instance for
type *T*, then there is an `Eq` instance for *T*.

# Advanced Haskell language constructs

## What is a Haskell program?

This subsection contains the essential vocabulary which is needed to
speak about Haskell programs.

### Organization of Haskell source code

Haskell module:
:   Group of Haskell definitions which are stored in a text file like
    `Example.hs`

Haskell library:
:   Haskell modules in hierarchical file structure

Haskell program (or executable):
:   Haskell modules with a main module

Haskell package:
:   Haskell library and/or a set of Haskell executables

### Phases of execution of Haskell programs

Knowing phases of execution helps to understand error messages.

1.  *lexical analysis*
    -   recognize the beginning and end of "words" and punctuation
        (these are called *tokens*)
    -   recognize layout (whitespace matters in Haskell)
    -   skip whitespace and comments
2.  *parsing*
    -   recognize language constructs
3.  loading imports
    -   (recursively) do these phases until code generation for all
        imported modules
4.  *scope checking*
    -   determine the defining location of each identifier
5.  reordering
    -   recognize hidden parentheses
    -   connect function declaration with function definition (can be
        apart)
6.  *type inference*
    -   check validity of expressions and declarations
7.  *optimization*
    -   transform definitions to make execution more time/space
        efficient
8.  *code generation*
    -   transform definitions to machine code (maybe for an abstract
        machine)
9.  *linking*
    -   compose code with code generated for imported modules
    -   compose code with RTS (*Runtime System*: code for builtin
        definitions, garbage collection, scheduling and profiling)
10. *execution* (called *runtime* when used as an adjective)
    -   execute the linked code

Phases 1-9 are called *compilation* (or *compilation time* when used as
an adjective).

Compilation is done by the compiler, execution is done by the operating
system.

### Possible programmer errors

Haskell programmers may cause the following kind of errors:

Compile time / static error:
:   error recognized during phases 1-6 by the compiler\
    (all compile time errors are caught until the end of type checking)

Runtime error:
:   error during execution, recognized by the runtime system\
    (all errors are caught by the runtime system and not by the
    operating system)

Semantic error:
:   error during execution which is not recognized by the runtime
    system\
    (may be recognized by testing)

Performance issue:
:   runtime resource usage is not acceptable / not reasonable\
    (may be recognized by profiling and benchmarks)

### Cached results

Recompilation of modules can be avoided by caching the results of the
compilation phases.

Executable file:
:   cached result of linking

Object file:
:   cached result of code generation, needed for linking

Interface file:
:   cached result of type checking, needed in phases 3-7 for modules
    importing this one

## Kinds

Kinds are the types of type expressions.

### Kinds of type constructors

    Int  :: *               -- Int is a type
    Char :: *               -- Char is a type
    Bool :: *               -- Bool is a type
    []   :: * -> *          -- list is a function from types to types
                            --  or: list is type parameterized by a type

<!-- -->
    (,)   :: * -> * -> *            -- same as  * -> (* -> *)
    (,,)  :: * -> * -> * -> *       -- same as  * -> (* -> (* -> *))
    (,,,) :: * -> * -> * -> * -> *
    ...

<!-- -->
    (->) :: * -> * -> *     -- almost, see later

In `ghci`:

    Prelude> :k Int
    Int :: *

### Type application

Type application has the same syntax as function application.

Partial application is possible:

    (,,)                 :: * -> * -> * -> *    -- no application
    (,,) Int             :: * -> * -> *         -- partial application
    (,,) Int Char        :: * -> *              -- partial application
    (,,) Int Char Bool   :: *                   -- full application; same as (Int, Char, Bool)

(Partial application of type synonyms is not allowed, see [type
sysnonyms](#type-type-synonym-definition).)

Kind mismatch is rejected by the compiler:

    (,) Maybe           -- *wrong*, kind mismatch at application
    (,) Int Char Bool   -- *wrong*, overapplication of type constructor (,)
    Int Char            -- *wrong*, overapplication of type constructor Int

### Kind of constraints

    Num                 :: * -> Constraint
    Num Int             :: Constraint
    Num a               :: Constraint           -- if a :: *
    (Num Int, Eq Int)   :: Constraint

<!-- -->
    Num a => a          :: *      -- as if  (=>) :: Constraint -> * -> *

### Type expression vs.Â type vs.Â type constructor

**Type expression** or type-level expression is an expression at the
type level, like `Maybe Int`.

**Type** is a type expression with kind `*`.

Sometimes 'type' is said instead of 'type expression' which may cause
confusion.

Every expression should have a *type*. For example, this hole cannot be
filled: `_ :: Maybe`.

**Type constructor** is a type expression defined by `data` and
`newtype`.\
There are some built-in type constructors too: `(->)`, `[]`, `()`,
`(,)`, `(,,)`, ...

Examples:

                  -- type expression?    type?    type constructor?
    Int           --  yes                 yes      yes
    Maybe Int     --  yes                 yes      no
    String        --  yes                 yes      no
    Maybe         --  yes                 no       yes
    (,,) Int      --  yes                 no       no

### Other kinds

Kinds which are beyond the scope of this tutorial:

-   kind variables
-   types lifted to the kind level, for example the kind of type-level
    natural numbers
-   The kind of a type may be other than `*`. The kind of a type `T`
    encodes the calling convention of expressions of type `T`; `*` is
    the kind of *lifted* types (whose values are accessed by a pointer).

    Remember this when you ask the kind of the function type
    constructor:

        > :k (->)
        (->) :: TYPE q -> TYPE r -> *

## Declarations (2)

### Fixity declaration

    infix  4  ==, /=    -- (==) and (/=) are non-associative
    infixl 6  +         -- (+) is left-associative; (+) is stronger than (==)
    infixr 0  $         -- ($) is right-associative; 0 is the lowest precedence level
    infixr 9  .         --                           9 is the highest precedence level

For more examples see [fixity declarations in
Prelude](#fixity-declarations-in-prelude)

### `type` -- type synonym definition

Definition of type synonyms:

    type String = [Char]        -- 'type' 

Note that `String` has a constructor name (begins with an uppercase
letter), but `String` is *not* a type constructor; it is a defined
constant at the type level similarly to `otherwise = True` at the value
level.

#### Type synonyms with parameters

Type synonyms may have 0 or more parameters:

    type Two a = (a, a)     -- 'Two Int' is equal to '(Int, Int)'

The *arity* of the type synonym is the number of its parameters.

Partial application of type synonyms is not allowed:

    type Tw = Two         -- *wrong*, use 'type Tw a = Two a'

<!-- -->
    instance Functor Two  -- *wrong*, turn 'Two' into a newtype; see later

### `data` -- algebraic data type definition

`data` defines a new *algebraic data type*, which consists of a type
constructor and zero or more (expression) constructors.

For example,

    data Bool = False | True        -- 2 constructors
                                    -- (False and True are in expression namespace)

defines

    Bool :: *           -- type constructor
    False :: Bool       -- constructor, so False is a pattern too
    True  :: Bool       -- constructor, so True is a pattern too

The type constructor and the constructor may have the same name because
they are in different namespaces:

    data Example{-type-} = Example{-expression-} | OtherExampleConstructor

#### Constructor fields

Constructors may have zero or more *fields* holding any type of data.
For example,

    data Complex = Pair Double Double       -- Pair has two Double fields

defines

    Complex :: *
    Pair :: Double -> Double -> Complex     -- Pair can be used in patterns

<!-- -->
    re :: Complex -> Double
    re (Pair r _) = r                 -- Pair used in a pattern

Pandoc examples:

`Alignment`, `QuoteType`, `MathType`

#### ADTs with parameters

Algebraic data types may have zero or more *parameters*, for example:

    data Complex a = Pair a a

#### Recursive ADTs

Algebraic data types may be recursive, for example:

    data Nat = Zero | Suc Nat

<!-- -->
    data BinaryTree a b
        = Leaf a
        | Node 
            (BinaryTree a b)    -- left subtree
            b                   -- value at node
            (BinaryTree a b)    -- right subtree

Mutual recursion is also allowed.

#### Records

Fields of constructors can be named. For example,

    data Complex = Pair {re :: Double, im :: Double}

defines

    Complex :: *
    Pair :: Double -> Double -> Complex
    re :: Complex -> Double                 -- field accessor function
    im :: Complex -> Dobble                 -- field accessor function

Moreover, the following expressions are valid

    Pair {re = 3, im = 4}           -- record construction, same as 'Pair 3 4'
    Pair {im = 4, re = 3}           -- record construction, same as 'Pair 3 4'
    p {re = 3}                      -- record update, same as 'Pair 3 (im p)'
    p {im = 4}                      -- record update, same as 'Pair (re p) 4'

Record syntax is especially useful when the constructor has many fields.

Record syntax is also possible if the ADT has more than one constructor.

Contracted syntax:

    data Complex = Pair {re, im :: Double}

Pandoc examples:

`Citation`

### `newtype` definition

Until the end of type checking phase, `newtype` is similar to `data`
with the following constraints:

-   Exactly one constructor is defined
-   Exactly one field of the constructor is defined

After the type checking phase, `newtype` behaves like a type synonym.

Example from Pandoc:

    newtype Format = Format String
        -- behaves as 'data Format = Format String' until the end of type checking
        -- behaves as 'type Format = String'        after type checking

Advantages of `newtype` over `type`:

-   `Format` and `String` are two distinct types
    -   less error prone
    -   they can have different `Show`, `Read`, ... instances
-   `newtype` definitions may be recursive, unlike type synonyms
-   `newtype` defines a type constructor which can be partially applied
    (in case of parametric newtypes)

Advantages of `newtype` over `data`:

-   better runtime performance
-   see `GeneralizedNewtypeDeriving`

### `class` definition

Example:

    class Eq a
      where
        (==) :: a -> a -> Bool
        (/=) :: a -> a -> Bool

defines

    Eq :: * -> Constraint               -- type class constructor
    (==) :: Eq a => a -> a -> Bool      -- type class method
    (/=) :: Eq a => a -> a -> Bool      -- type class method

The implementations of `(==)` and `(/=)` are given in the instance
definitions.

#### Default methods

Default implementation of methods:

    class Eq a
      where
        (==) :: a -> a -> Bool
        x == y = not (x /= y)           -- used if the instance does not implement (==)

        (/=) :: a -> a -> Bool
        x /= y = not (x == y)           -- used if the instance does not implement (/=)

#### Superclasses

    class Eq a => Ord a             -- Eq is a superclass of Ord
      where
        (<) :: a -> a -> Bool

-   an `Ord` instance is definable on a type only if an `Eq` instance is
    defined already
-   the constraint `Ord a` implies `Eq a`, so one can simplify the
    constraint `(Eq a, Ord a)` to `Ord a`

### `instance` definition

Examples:

    instance Eq Bool
      where
        True  == True  = True
        False == False = True
        _     == _     = False

        -- -- (/=) is not implemented, so the compiler defines it as:
        -- x /= y = not (x == y)

<!-- -->
    instance Eq a => Eq [a] where
        []     == []     = True
        (x:xs) == (y:ys) = x == y && xs == ys       -- the second (==) is recursion
        _      == _      = False

<!-- -->
    instance (Eq a, Eq b) => Eq (a, b) where
        (a1, b1) == (a2, b2) = a1 == a2 && b1 == b2

These instance definitions are used recursively to solve the following
constraints:

    Eq Bool
    Eq [Bool]
    Eq (Bool,Bool)
    Eq [[Bool]]
    Eq [(Bool,Bool)]
    Eq ([Bool],[Bool])
    Eq ((Bool,Bool),[Bool])
    -- ...

## Modules

General module structure:

    {-# LANGUAGE CPP #-}                        -- 0 or more language extension pragmas

    module X where                              -- module header (may be missing)

    import Prelude                              -- 0 or more import declarations

    x = 1                                       -- 0 or more other declarations

### Language pragmas

Language extension pragmas extend the Haskell98 language.

Syntax:

    {-# LANGUAGE CPP #-}              -- 'language' (with lowercase letters) is also good
    {-# LANGUAGE PatternGuards #-}

or packed together:

    {-# LANGUAGE CPP, PatternGuards #-}

The language extensions used by Pandoc are discussed at [Haskell
language extensions](#haskell-language-extensions).

### Module header

Simple module header:

    module A.B.C where      -- this module should be located at A/B/C.hs in the filesystem
                            --  otherwise it cannot be imported by other modules

Modules called `Main` has an extra requirement:

    module Main where       -- 'main' should be defined in the module

No module header is also possible:

    -- no header --         -- same as  'module Main where',  but 'main' is not required

#### Export list

Export list is placed after the module name:

    module A.B.C          -- What is exported?
        ( A               -- - A from type namespace
                          --   (type synonym / type constructor / type class with instances)
        , B (..)          -- - B from type namespace with all parts
                          --   (constructors, field accessors / methods)
        , C (D, (:+:), e) -- - C from type namespace with listed parts
                          --   (constructors D and (:+:), field accessor / method e)
        , f               -- - f from expression namespace (function / constant)
        , (++)            -- - operator (++)
        , module X        -- - everything which is exported by X
        , module A.B.C    -- - everything which is defined in this module
        ) where

Empty export list or no export list is possible:

    module A.B.C () where   -- nothing is exported

<!-- -->
    module A.B.C where      -- same as  'module A.B.C (module A.B.C) where'
                            -- (exports everything which is defined in this module)

### Import declaration

Examples of import declarations:

    import A.B.C          -- import everything which A.B.C exports

<!-- -->
    import X              -- import from module X:
        ( A               -- - A from type namespace
        , B (..)          -- - B from type namespace with all parts
        , C (D, (:+:), e) -- - C from type namespace with listed parts
        , f               -- - f from expression namespace
        , (++)            -- - operator (++)
        )

<!-- -->
    import Y hiding       -- import everything which Y exports, but do not import
        (A, B (..), C (D, (:+:), e), f, (++))                      -- these items

`Prelude` is implicitly imported:

    import Prelude        -- this line is added if 'Prelude' is not imported explicitly

#### Qualify imported identifiers

Any imported identifiers can be used qualified in expressions:

    three = Prelude.id 3  -- 'id' imported from 'Prelude', applied on 3

One can change the needed qualification at the import declaration:

    import A.B.C as ABC   -- 'ABC.id' means now 'A.B.C.id', and 'A.B.C.id' is not in scope

Other examples:

    import A.B.C as ABC (x, y)            -- combination with list of imported items

<!-- -->
    import A.B.C as ABC hiding (x, y)     -- combination with hiding

These tricks are allowed:

    import A as C
    import B as C    -- same qualifications, especially useful when exporting 'module C'

<!-- -->
    import A
    import B as A               -- use the same qualification

<!-- -->
    import A as B
    import B as A               -- swap qualifications (not nice)

#### Require qualification of imported identifiers

With keyword `import qualified`, one can prohibit unqualified use of the
imported identifiers:

    import qualified Prelude    -- now 'id' is not in scope, only 'Prelude.id'

`import qualified` can be used as `import`.\
Examples:

    import qualified Prelude (id)

<!-- -->
    import qualified Prelude hiding (id)

<!-- -->
    import qualified Prelude as P hiding (id)

## Haskell language extensions

The following language extensions are used by Pandoc:

-   preprocessing: [`CPP`](#cpp)
-   imports: `NoImplicitPrelude`
-   syntactic sugars
    -   expression related: `TupleSections`, `MultiWayIf`, `LambdaCase`
    -   pattern related: `PatternGuards`,
        [`ViewPatterns`](#viewpatterns)
    -   both for expressions and patterns: `OverloadedStrings`
-   type class extensions
    -   classes: `MultiParamTypeClasses`
    -   instances: `FlexibleInstances`, `TypeSynonymInstances`,
        `IncoherentInstances`, `UndecidableInstances`
        -   deriving: `GeneralizedNewtypeDeriving`,
            `DeriveDataTypeable`, `DeriveGeneric`
    -   contexts: `FlexibleContexts`
-   types: `ExplicitForAll`, `ScopedTypeVariables`, `RelaxedPolyRec`
-   type declaration: `GADTs`
-   other: `TemplateHaskell`

### `CPP`

CPP stands for C PreProcessor.

CPP is used for conditional compilation. Typical use cases for
conditional compilation:

-   backward compatibility for library dependencies
-   allow the code to be platform-dependent
-   turn features on/off in a library or executable

Syntax: one CPP directive per line, *without indentation*.

CPP directives used in Pandoc:

-   `#if` *condition*
-   `#ifdef` *macro*
-   `#ifndef` *macro*
-   `#else`
-   `#endif`

`#if`, `#ifdef` and `#ifndef` need a matching `#endif`.

`#else` is optional but should be placed between an `#if`... and an
`#endif` pair.

#### Example: `#if` used for backward compatibility

    #if MIN_VERSION_base(4,8,3)
    import System.IO.Error (IOError, isDoesNotExistError)
    #else
    import System.IO.Error (isDoesNotExistError)
    #endif

#### Example: `#ifdef` and `#ifndef` used for platform-dependent code

    #ifndef _WINDOWS
    import System.Posix.IO (stdOutput)
    import System.Posix.Terminal (queryTerminal)
    #endif

Later in the same module, in a `do` block:

    #ifdef _WINDOWS
      let istty = True
    #else
      istty <- queryTerminal stdOutput
    #endif

#### Example: turn a feature on/off

cabal package flags define CPP macros (see later):

    #ifdef EMBED_DATA_FILES

### `ViewPatterns`

View patterns allows to apply a function *before* pattern matching.

Example:

    initLast xs = (init xs, last xs)

    reverse (initLast -> (xs, x)) = x: reverse xs

Example:

    greet (words -> ["My","name","is",x]) = "Hello " ++ x
    greet (words -> ["I","am",x]) = "Hi " ++ x
    greet xs = "I don't understand " ++ show xs

is the same as

    greet xs = case words xs of
        ["My","name","is",x] -> "Hello " ++ x
        ["I","am",x] -> "Hi " ++ x
        _ -> "I don't understand " ++ show xs

# Advanced Haskell declarations

## Monoids

TODO

### `Sum` monoid

[`Data.Monoid`](https://hackage.haskell.org/package/base/docs/Data-Monoid.html)
defines:

    newtype Sum a = Sum { getSum :: a }

<!-- -->
    instance Num a => Monoid (Sum a)

Usage example:

    -- foldMap :: Monoid m => (a -> m) -> t a -> m
    getSum $ foldMap Sum [1,2,3,4]

## Text representations

### List of characters

    type String = [Char]         -- defined in Prelude

Pros:

-   automatically imported (defined in `Prelude`)
-   generic list operations can be used (`take`, `drop`, `replicate`,
    ...)
-   the head and the tail can be matched with the `(:)` pattern

Cons:

-   memory inefficient
-   time inefficient

### Packed unicode texts

[API on
Hackage](https://hackage.haskell.org/package/text/docs/Data-Text.html)

    module Data.Text

    data Text

    instance Eq Text
    instance Ord Text
    instance Monoid Text
    instance IsString Text
    ...

    pack :: String -> Text
    unpack :: Text -> String

    take :: Int -> Text -> Text
    drop :: Int -> Text -> Text
    takeEnd :: Int -> Text -> Text
    dropEnd :: Int -> Text -> Text
    ...

<!-- -->
    import Data.Text.IO

    readFile :: FilePath -> IO Text
    writeFile :: FilePath -> Text -> IO () 
    ...

Pros:

-   memory and time efficient
-   convenient & fast functions like `takeEnd` and `dropEnd`

Cons:

-   should be imported, with `qualified` import
-   string literals work only with the `OverloadedString` language
    extension
-   pattern matching works only with the `ViewPatterns` or
    `PatternSynonyms` language extension

### Chunks of packed unicode texts

    module Data.Text.Lazy

    import qualified Data.Text as Strict

    data Text

    ...

    toStrict :: Text -> Strict.Text
    fromStrict :: Strict.Text -> Text

Has the same API as `Data.Text` but optimized for streaming large
quantities of data.

Pros (compared to `Data.Text`):

-   The whole text can be bigger than the memory; only the part which
    are worked on should fit into memory.
-   some operations may be faster

Cons (compared to `Data.Text`):

-   some operations may be slower

### Packed bytes (low-level)

    module Data.ByteString

    data ByteString

    instance Eq ByteString
    instance Ord ByteString
    instance Monoid ByteString
    instance IsString ByteString
    ...

    pack :: [Word8] -> ByteString
    unpack :: ByteString -> [Word8] 

    take :: Int -> ByteString -> ByteString
    drop :: Int -> ByteString -> ByteString
    ...

    readFile :: FilePath -> IO ByteString
    writeFile :: FilePath -> ByteString -> IO ()
    ...

<!-- -->
    import Data.ByteString.Char8

    pack :: String -> ByteString
    unpack :: ByteString -> String

`ByteString` is *not* a proper text representation, it should be used
for storing binary data or ASCII texts.

### Chunks of packed bytes

    module Data.ByteString.Lazy

    import qualified Data.ByteString as Strict

    data ByteString

    ...

    toStrict :: ByteString -> Strict.ByteString
    fromStrict :: Strict.ByteString -> ByteString

Has the same API as `Data.ByteString` but optimized for streaming large
quantities of data.

Pros (compared to `Data.ByteString`):

-   The whole string can be bigger than the memory; only the part which
    are worked on should fit into memory.
-   some operations may be faster

Cons (compared to `Data.ByteString`):

-   some operations may be slower

## Containers

### `Maybe` values

*Entities in this section are defined in `Prelude` or `Data.Maybe`.*

Type

    Maybe :: * -> *          --- list with most one value

Instances

    instance   Eq a => Eq (Maybe a)
    instance  Ord a => Ord (Maybe a)
    instance Show a => Show (Maybe a)
    instance Read a => Read (Maybe a)

Constructors

    Nothing   :: Maybe a                --- corresponds to the empty list
    Just      :: a -> Maybe a           --- result corresponds to the singleton list

Functions

    isNothing :: Maybe a -> Bool        --- is empty
    isJust    :: Maybe a -> Bool        --- is non-empty
    maybe     :: b -> (a -> b) -> Maybe a -> b    --- eliminator for Maybe
    find      :: Foldable t => (a -> Bool) -> t a -> Maybe a   --- first element by condition
    lookup    :: Eq a => a -> [(a, b)] -> Maybe b           --- lookup in an association list

### `Either` -- disjoint union

*Entities in this section are defined in `Prelude`.*

Type

    Either :: * -> * -> *    --- disjunct union

Instances

    instance     (Eq a, Eq b) => Eq (Either a b)
    instance   (Ord a, Ord b) => Ord (Either a b)
    instance (Show a, Show b) => Show (Either a b)
    instance (Read a, Read b) => Read (Either a b)

Constructors

    Left   :: a -> Either a b    --- tag elements of the first type
    Right  :: b -> Either a b    --- tag elements of the second type

Functions

    either :: (a -> c) -> (b -> c) -> Either a b -> c    --- eliminator for Either

### `Set`

    Set a       ~      a -> Bool
    Map a b     ~      a -> Maybe b
    Seq a       ~      [a]

<https://hackage.haskell.org/package/containers>

Semantics:

    Set.fromList ['a', 'a']  ==  Set.fromList ['a']
    Set.fromList ['a', 'b']  ==  Set.fromList ['b', 'a']

<!-- -->
    Set a       ~      a -> Bool  +  toList
    Set a       ~      [a]  -  sorrend  -  duplikÃ¡tumok

basic operations:

    empty       :: Set a                     -- = mempty
    singleton   :: a -> Set a
    union       :: Ord a => Set a -> Set a -> Set a   -- = (<>)

    splitMember :: Ord a => a -> Set a -> (Set a, Bool, Set a)

    toList      :: Set a -> [a]

other operations:

    insert x xs
        = singleton x <> xs

<!-- -->
    unions
        = foldr (<>) mempty
        -- = mconcat

<!-- -->
    member x xs
        = b
      where (_, b, _) = splitMember x xs

<!-- -->
    delete x xs
        = ys <> zs
      where (ys, _, zs) = splitMember x xs

<!-- -->
    fromList
        = mconcat . map singleton

<!-- -->
    size
        = length . toList
        -- but more efficient, O(1)

<!-- -->
    null x
        = size x == 0

<!-- -->
    filter p
        = fromList . List.filter p . toList

<!-- -->
    intersection = ...

    difference = ...

persistence demo

Usage examples:

    module Text.Pandoc.Shared

    ...

    import qualified Data.Set as Set

    ...

    ordNub :: Ord a => [a] -> [a]
    ordNub l = go Set.empty l
      where
        go _ [] = []
        go s (x:xs) = if x `Set.member` s then go s xs
                                          else x : go (Set.insert x s) xs

    ...

    -- | Generate a unique identifier from a list of inlines.
    -- Second argument is a list of already used identifiers.
    uniqueIdent :: [Inline] -> Set.Set String -> String
    uniqueIdent = ...

    ...

    -- accepted uri-schemes by pandoc
    schemes :: Set.Set String
    schemes = Set.fromList
      [ "aaa", "aaas", "about", "acap", "acct", "acr", "adiumxtra", "afp", "afs"
      , "aim", "appdata", ...

    isURI :: String -> Bool
    isURI = maybe False hasKnownScheme . parseURI
      where
        hasKnownScheme = (`Set.member` schemes)
                       . map toLower
                       . uriScheme

<!-- -->
    module Text.Pandoc.Shared

    ...

    import qualified Data.Set as Set

    ...

    defaultAbbrevs :: Set.Set String
    defaultAbbrevs = Set.fromList
                     [ "Mr.", "Mrs.", "Ms.", "Capt.", "Dr.", "Prof.",
                       "Gen.", "Gov.", "e.g.", "i.e.", "Sgt.", "St.",
                       "vol.", "vs.", "Sen.", "Rep.", "Pres.", "Hon.",
                       "Rev.", "Ph.D.", "M.D.", "M.A.", "p.", "pp.",
                       "ch.", "sec.", "cf.", "cp."]

### `Map`

        Map.fromList [('a', 1), ('a', 2)]  ==  Map.fromList [('a', 2)]
        Map.fromList [('a', 1), ('b', 1)]  /=  Map.fromList [('b', 1)]
        Map.fromList [('a', 1), ('b', 2)]  ==  Map.fromList [('b', 2), ('a', 1)]

        Map a b     ~      a -> Maybe b   +   domain
        Map a b     ~      [(a, b)]  -  sorrend  -  duplikÃ¡tumok (az elsÅ‘ elem szerint)

<!-- -->
        Set a       ~      Map a ()

basic operations:

    empty       :: Map a b                     -- = mempty
    singleton   :: a -> b -> Map a b
    union       :: Ord a => Map a b -> Map a b -> Map a b   -- = (<>), left-biased

    splitLookup :: Ord a => a -> Map a b -> (Map a b, Maybe b, Map a b)

    toList      :: Map a b -> [(a, b)]

other operations:

    insert x a xs
        = singleton x a <> xs

<!-- -->
    unions
        = foldr (<>) mempty
        -- = mconcat

<!-- -->
    lookup x xs
        = b
      where (_, b, _) = splitLookup x xs

<!-- -->
    member x xs
        = maybe False (const True) (lookup x xs)

<!-- -->
    delete x xs
        = ys <> zs
      where (ys, _, zs) = splitLookup x xs

<!-- -->
    fromList
        = mconcat . map (uncurry singleton)

<!-- -->
    size
        = length . toList
        -- but more efficient, O(1)

<!-- -->
    null x
        = size x == 0

<!-- -->
    filter p
        = fromList . List.filter (p . fst) . toList

<!-- -->
    intersection = ...

    difference = ...

Usage examples:

    Text.Pandoc.Emoji
    -- sudo apt install ttf-ancient-fonts

<!-- -->
    module Text.Pandoc.Asciify

<!-- -->
    module Text.Pandoc.MIME

<!-- -->
    -- Text.Pandoc.Definition
    newtype Meta = Meta { unMeta :: M.Map String MetaValue }

<!-- -->
    -- Text.Pandoc.MediaBag
    -- | A container for a collection of binary resources, with names and
    -- mime types.
    newtype MediaBag = MediaBag (M.Map [String] (MimeType, BL.ByteString))

<!-- -->
    Data.Map   -->   Data.Map.Lazy
    Data.Map.Strict     -- not used in Pandoc

### `Seq`

    module Data.Sequence

semantics:

        Seq a       ~      [a]

basic operations:

    empty       :: Seq a                     -- = mempty
    singleton   :: a -> Seq a
    (><)        :: Ord a => Seq a -> Seq a -> Seq a   -- = (<>)

    splitAt     :: Ord a => Int -> Seq a -> (Seq a, Seq a)

    viewl       :: Seq a -> ViewL a

    -- | View of the left end of a sequence.
    data ViewL a
        = EmptyL        -- ^ empty sequence
        | a :< Seq a    -- ^ leftmost element and the rest of the sequence

    viewr       :: Seq a -> ViewR a

    -- | View of the right end of a sequence.
    data ViewR a
        = EmptyR        -- ^ empty sequence
        | Seq a :> a    -- ^ the sequence minus the rightmost element,
                        -- and the rightmost element

other operations:

    x <| xs                     -- O(1)
        = singleton x <> xs

<!-- -->
    xs |> x                     -- O(1)
        = xs <> singleton x

<!-- -->
    fromList
        = foldr (<>) mempty
        -- = mconcat

<!-- -->
    toList = ...

<!-- -->
    splitMemberAt :: Ord a => Int -> Seq a -> (Seq a, Maybe a, Seq a)
    -- nincs, de lehet definiÃ¡lni

<!-- -->
    lookup i xs
        = b
      where (_, b, _) = splitMemberAt xs

<!-- -->
    deleteAt x xs
        = ys <> zs
      where (ys, _, zs) = splitMemberAt x xs

<!-- -->
    fromList
        = mconcat . map singleton

<!-- -->
    lenght
        = List.length . toList
        -- but more efficient, O(1)

<!-- -->
    null x
        = size x == 0

<!-- -->
    filter p
        = fromList . List.filter p . toList

<!-- -->
    take, drop, ...

Pandoc source code examples:

    module Text.Pandoc.Builder

    ...

    import Data.Sequence (Seq, (|>), viewr, viewl, ViewR(..), ViewL(..))      -- used unqualified
    import qualified Data.Sequence as Seq    -- everything else used qualified like Seq.singleton

    ...

    -- wrap Seq to be able to override the Monoid instance
    newtype Many a = Many { unMany :: Seq a }

    ...

    singleton :: a -> Many a
    singleton = Many . Seq.singleton    -- usage of Many to wrap

    ...

    isNull :: Many a -> Bool
    isNull = Seq.null . unMany          -- usage of unMany

    ...

    type Inlines = Many Inline
    type Blocks  = Many Block

    ...

    deriving instance Monoid Blocks          -- inherit  Monoid (Seq Block)

    instance Monoid Inlines where            -- override  Monoid (Seq Inline)
      mempty = Many mempty

      -- smart mappend
      (Many xs) `mappend` (Many ys) =        -- usage of Many to unwrap
        case (viewr xs, viewl ys) of
          (EmptyR, _) -> Many ys
          (_, EmptyL) -> Many xs
          (xs' :> x, y :< ys') -> Many (meld `mappend` ys')
            where meld = case (x, y) of
              (Space, Space)     -> xs' |> Space          -- Space behaves like maring in HTML
              (Space, SoftBreak) -> xs' |> SoftBreak      -- SoftBreak swallows Space on left
              (SoftBreak, Space) -> xs' |> SoftBreak      -- SoftBreak swallows Space on right

              -- automatic de-fragmentation
              (Str t1, Str t2)                 -> xs' |> Str (t1 <> t2)
              (Emph i1, Emph i2)               -> xs' |> Emph (i1 <> i2)
              (Strong i1, Strong i2)           -> xs' |> Strong (i1 <> i2)
              (Subscript i1, Subscript i2)     -> xs' |> Subscript (i1 <> i2)
              (Superscript i1, Superscript i2) -> xs' |> Superscript (i1 <> i2)
              (Strikeout i1, Strikeout i2)     -> xs' |> Strikeout (i1 <> i2)

              -- LineBreak swallows Space and SoftBreak
              (Space, LineBreak)     -> xs' |> LineBreak
              (LineBreak, Space)     -> xs' |> LineBreak
              (SoftBreak, LineBreak) -> xs' |> LineBreak
              (LineBreak, SoftBreak) -> xs' |> LineBreak

              (SoftBreak, SoftBreak) -> xs' |> SoftBreak -- SoftBreak behaves like maring in HTML

              _ -> xs' |> x |> y                        -- every other cases: like normal mappend

-   `Seq Inline` is strictly better than `[Inline]` as a representation
    of `Inlines`
    -   O(1) access of the last elem in `Inlines`
    -   O(1) concatenation of `Inlines`

Examples of `Monoid Inlines` usage: see later

    -- | Trim leading and trailing spaces and softbreaks from an Inlines.
    trimInlines :: Inlines -> Inlines
    trimInlines (Many ils) = Many $ Seq.dropWhileL isSp $
                                Seq.dropWhileR isSp $ ils
      where isSp Space = True
            isSp SoftBreak = True
            isSp _ = False

<!-- -->
    -- | Convert a 'String' to 'Inlines', treating interword spaces as 'Space's
    -- or 'SoftBreak's.  If you want a 'Str' with literal spaces, use 'str'.
    text :: String -> Inlines
    text = fromList . map conv . breakBySpaces

      where breakBySpaces = groupBy sameCategory

            sameCategory x y = (is_space x && is_space y) ||
                               (not $ is_space x || is_space y)

            conv xs | all is_space xs =
               if any is_newline xs
                  then SoftBreak
                  else Space
            conv xs = Str xs

            is_space ' '    = True
            is_space '\r'   = True
            is_space '\n'   = True
            is_space '\t'   = True
            is_space _      = False

            is_newline '\r' = True
            is_newline '\n' = True
            is_newline _    = False

Example usage:

    Prelude Text.Pandoc.Builder> text "hello world!"
    Many {unMany = fromList [Str "hello",Space,Str "world!"]}

<!-- -->
    Prelude Text.Pandoc.Builder> text " hello " <> text " world "
    Many {unMany = fromList [Space,Str "hello",Space,Str "world",Space]}

`str` does not process the `String`:

    str :: String -> Inlines
    str = singleton . Str

<!-- -->
    Prelude Text.Pandoc.Builder> str "hello world!"
    Many {unMany = fromList [Str "hello world!"]}

### `Foldable` type class

The essence of the `Foldable` class:

    class Foldable t where      -- t can be seen as a list
      toList :: t a -> [a]

Some predefined instances:

    instance Foldable []
    instance Foldable Set
    instance Foldable Maybe   -- Maybe value as list with zero or one element
    instance Foldable Complex -- toList :: Complex a -> [a],  the complex number as a 2-elem list 

Functions which consume lists are generalized to `Foldable`:

    length  :: (Foldable t) => t a -> Int
    null    :: (Foldable t) => t a -> Bool
    elem    :: (Foldable t, Eq a => a -> t a -> Bool
    sum     :: (Foldable t, Num a => t a -> a 
    maximum :: (Foldable t, Ord a) => t a -> a
    foldr   :: (Foldable t) => (a -> b -> b) -> b -> t a -> b
    foldl   :: (Foldable t) => (b -> a -> b) -> b -> t a -> b
    ...

Unfortunately, the performance of these functions could drop
dramatically if we define them with `toList` (and not with `Set.size`,
for example):

    -- just an example
    length  :: (Foldable t) => t a -> Int
    length = List.length . toList               -- wrong, List.length is an O(n) operation

To be able to specialize `length` on `Set`, the `length` method was
included into `Foldable`:

    class Foldable t where      -- t can be seen as a list
      toList :: t a -> [a]
      length :: t a -> Int

<!-- -->
    instance Foldable Set where
      length = size    -- O(1)
      ...

The similar happened to the other functions, so eventually `Foldable`
looks like this...

    class Foldable t where
        toList  :: t a -> [a]
        length  :: t a -> Int
        elem    :: Eq a => a -> t a -> Bool             -- note the extra Eq constraint
        maximum :: Ord a => t a -> a
        minimum :: Ord a => t a -> a
        sum     :: Num a => t a -> a
        product :: Num a => t a -> a
        foldr   :: (a -> b -> b) -> b -> t a -> b
        foldr'  :: (a -> b -> b) -> b -> t a -> b       -- strict foldr
        foldl   :: (b -> a -> b) -> b -> t a -> b
        foldl'  :: (b -> a -> b) -> b -> t a -> b       -- strict foldl
        foldr1  :: (a -> a -> a) -> t a -> a
        foldl1  :: (a -> a -> a) -> t a -> a
        fold    :: Monoid m => t m -> m                 -- general fold
        foldMap :: Monoid m => (a -> m) -> t a -> m

Most members has a default implementation (omitted from above):

    class Foldable t where
        ...
        elem :: Eq a => a -> t a -> Bool
        elem = any . (==)
        ...

    -- | Determines whether any element of the structure satisfies the predicate.
    any :: Foldable t => (a -> Bool) -> t a -> Bool
    any p = ... -- defined with foldMap, see later

As a result, `Foldable` instances need to define at least `foldMap` or
`foldr`.

Example instance:

    data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)

    instance Foldable Tree where
       foldMap f Empty = mempty
       foldMap f (Leaf x) = f x
       foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r

Good to see how `foldMap` and `foldr` are defined by each-other:

    foldMap :: Monoid m => (a -> m) -> t a -> m
    foldMap f = foldr (mappend . f) mempty

<!-- -->
    foldr :: (a -> b -> b) -> b -> t a -> b
    foldr f z t = appEndo (foldMap (Endo . f) t) z

`Endo` is defined in `Data.Monoid`:

    newtype Endo a = Endo { appEndo :: a -> a }

    instance Monoid (Endo a) where
        mempty = Endo id
        Endo f `mappend` Endo g = Endo (f . g)

Help to understand how it works:

        foldr (+) 0 [1,2,3]
     == appEndo (foldMap (Endo . (+)) [1,2,3]) 0
     == appEndo (Endo (1+) <> Endo (2+) <> Endo (3+)) 0
     == appEndo (Endo ((1+) . (2+) . (3+))) 0              -- appEndo cancels Endo
     == ((1+) . (2+) . (3+)) 0
     == (1+) ((2+) ((3+) 0))
     == 6

### `Functor` type class

`Functor` could be called `Mappable` because it is a generalization of
`map` and similar functions:

    map :: (a -> b) -> [a] -> [b]

    data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)

    mapTree :: (a -> b) -> Tree a -> Tree b
    mapTree f Empty = Empty
    mapTree f (Leaf x) = Leaf (f x)
    mapTree f (Node l k r) = Node (mapTree f l) (f k) (mapTree f r)

The generalized function should be something like:

    fmap :: Functor t => (a -> b) -> t a -> t b    -- read Functor as Mappable

`fmap` has this type indeed. `fmap` is a class member, so the actual
definition looks like

    class Functor t where
      fmap :: (a -> b) -> t a -> t b

There is an operator form for `fmap`:

    (<$>) :: Functor f => (a -> b) -> f a -> f b
    (<$>) = fmap

    infixl 4 <$>

Some predefined instances

    instance Functor [] -- Defined in â€˜GHC.Baseâ€™
    instance Functor Maybe -- Defined in â€˜GHC.Baseâ€™
    instance Functor ((,) a) -- Defined in â€˜GHC.Baseâ€™
    instance Functor (Either a) -- Defined in â€˜Data.Eitherâ€™
    instance Functor ((->) r) -- Defined in â€˜GHC.Baseâ€™
    instance Functor IO -- Defined in â€˜GHC.Baseâ€™

Use examples:

    Prelude> even <$> [1,2,3]
    [False,True,False]
    Prelude> even <$> Just 5
    Just False
    Prelude> even <$> Nothing
    Nothing
    Prelude> even <$> (1,2)
    (1,True)
    Prelude> even <$> Left 1
    Left 1
    Prelude> even <$> Right 2
    Right True
    Prelude> (even <$> (+1)) 3
    True

<!-- -->
    Prelude Data.Char> isAscii <$> getChar
    2True

Pandoc use examples: a lot, TODO

## Custom classes

Given the following types:

    -- | Metadata for the document:  title, authors, date.
    newtype Meta = Meta { unMeta :: M.Map String MetaValue }

<!-- -->
    data MetaValue = MetaMap (M.Map String MetaValue)
                   | MetaList [MetaValue]
                   | MetaBool Bool
                   | MetaString String
                   | MetaInlines [Inline]
                   | MetaBlocks [Block]

We would like to have a polymorph `setMeta`:

    setMeta "title" (text "The title") meta   --  :: String -> Inlines -> Meta -> Meta
    setMeta "title" (text "The title") doc    --  :: String -> Inlines -> Pandoc -> Pandoc
    setMeta "author" [text "author #1", text "author #2"] doc
                                              --  :: String -> [Inlines] -> Pandoc -> Pandoc

so `setMeta` should have type something like

    setMeta :: (MetaSettable b a) => String -> b -> a -> a

or better if we can factor the constraint `(MetaSettable b a)` into
`(ToMetaValue b, HasMeta a)` because we have to define less instances
later:

    setMeta :: (ToMetaValue b, HasMeta a) => String -> b -> a -> a

What should be `ToMetaValue`?

    class ToMetaValue a where
      toMetaValue :: a -> MetaValue

<!-- -->
    instance ToMetaValue Bool where
      toMetaValue = MetaBool

<!-- -->
    instance ToMetaValue Inlines where
      toMetaValue = MetaInlines . toList

<!-- -->
    instance ToMetaValue a => ToMetaValue [a] where
      toMetaValue = MetaList . map toMetaValue

<!-- -->
    instance ToMetaValue MetaValue where
      toMetaValue = id

What should be `HasMeta`? The idiomatic solution would be

    class HasMeta a where
      setMetaPre :: String -> MetaValue -> a -> a
      deleteMeta :: String -> a -> a

    setMeta :: (ToMetaValue b, HasMeta a) => String -> b -> a -> a
    setMeta key val = setMetaPre key (toMetaValue val)

The actual solution does the same thing with a bit more work. <link>

To specialize the too polymorph `setMeta` some wrappers are defined with
restricted types:

    setTitle :: Inlines -> Pandoc -> Pandoc
    setTitle = setMeta "title"

    setAuthors :: [Inlines] -> Pandoc -> Pandoc
    setAuthors = setMeta "author"

    setDate :: Inlines -> Pandoc -> Pandoc
    setDate = setMeta "date"

Usage examples: in the haddock documentation of `Text.Pandoc.Builder`.
<link>

## `IO` actions

### The `IO` type constructor

`IO` is a built-in type constructor:

    IO :: * -> *

`IO a` is the type of *codes of interactive programs* which return an
`a`-typed value when the program terminates.

We say **IO action** or just **action** instead of "code of an
interactive program".

Examples of types constructed with `IO`, giving an element for each:

    -- getChar  is the action which waits for a character and returns it
    getChar  :: IO Char

    -- (putChar c) is the action of putting c on the console
    putChar  :: Char -> IO ()

    -- (sequence xs) is the action which performs actions xs and returns their collected results
    sequence :: [IO a] -> IO [a]

    -- (sequence_ xs) is the action which performs actions xs and returns ()
    sequence_ :: [IO a] -> IO ()

    -- (pure x) is the action which returns x (does not have side effect)
    pure     :: a -> IO a

    -- (join x) is the action which first performs x, then performs the action returned by x
    join     :: IO (IO a) -> IO a

Examples of actions constructed from smaller actions:

    putStr :: String -> IO ()
    putStr s = sequence_ (map putChar s)

    putStrLn :: String -> IO ()
    putStrLn s = putStr (s ++ "\n")

    getLine :: IO String
    getLine = join (f <$> getChar)  -- instance Functor IO
      where
        f :: Char -> IO String
        f '\n' = pure []
        f c = (c:) <$> getLine

You may noticed that there is `instance Functor IO`.

### Performing actions

Actions i.e.Â codes of interactive computations can be run in two ways:

A)  Compile & run the code

    1.  define `main :: IO ()`
    2.  compile the definition
    3.  run the resulted executable program (maybe several times)

B)  Interpret the code by entering the action in the Haskell interpreter

Example A, step 1, definition of `main`:

    ~~~~~~~~~~~~~~ X.hs
    main :: IO () -- main should have this type
    main = join $ f . read <$> getLine
      where
        f :: Int -> IO ()
        f n = sequence_ $ replicate n $ putStrLn "Hello world!"
    ~~~~~~~~~~~~~~

Example A, step 2, compiling `main`:

``` {.bash}
$ ghc X
[1 of 1] Compiling Main             ( X.hs, X.o )
Linking X ...
```

Example A, step 3, running the executable (`2` is entered by the user):

``` {.bash}
$ ./X
2
Hello world!
Hello world!
```

Example B:

    > getLine
    hello               -- user input
    "hello"             -- result of getLine

Actions cannot be performed in Haskell definitions, because this makes
Haskell an impure language:

    -- not allowed in safe Haskell, breaks equational reasoning
    unsafePerformIO :: IO a -> a

    -- should be True, but it is mostly False
    shouldBeTrue :: Bool
    shouldBeTrue = s == s'
      where
        s = [c, c]
          where
            c = unsafePerformIO getChar

        s' = [unsafePerformIO getChar, unsafePerformIO getChar]

### Basic combinators

There are elementary actions and a set of basic combinators with which a
wide range of actions can be constructed.

Some elementary actions are the following:

    getChar    :: IO Char
    putChar    :: Char -> IO ()
    readFile   :: FilePath -> IO String       -- type FilePath = String
    writeFile  :: FilePath -> String -> IO ()
    appendFile :: FilePath -> String -> IO ()
    -- + operations on mutable variables and arrays
    -- + communication primitives between program threads
    -- + database operations
    -- + rendering images on the screen
    -- + communication between programs, http, ...

The set of basic combinators is much smaller:

    pure   :: a             -> IO a                 -- actions without side effects

    (<$>)  :: (a -> b)      -> IO a -> IO b         -- apply a function on the returned value

    liftA2 :: (a -> b -> c) -> IO a -> IO b -> IO c -- combine two actions with a function

    join   :: IO (IO a) -> IO a                     -- flatten an action-returning action

Other combinators can be defined on top of the basic combinators.\
For example, `sequence`, `sequence_`, `liftA5` and `join2` can be
defined as:

    sequence :: [IO a] -> IO [a]
    sequence [] = pure []
    sequence (a: as) = liftA2 (:) a (sequence as)

    (>>) :: IO a -> IO b -> IO b
    ia >> ib = liftA2 (\_ b -> b) ia ib         -- or:   (>>) = liftA2 (const id)

    sequence_ :: [IO a] -> IO ()
    sequence_ [] = pure ()
    sequence_ (a: as) = a >> sequence_ as

    (<*>) :: IO (a -> b) -> IO a -> IO b
    iab <*> ia = liftA2 ($) iab ia              -- or:   (<*>) = liftA2 ($)

    infixl 4 <$>, <*>

    liftA5 :: (a -> b -> c -> d -> e -> f) -> IO a -> IO b -> IO c -> IO d -> IO e -> IO f
    liftA5 f ia ib ic id ie  =  f <$> ia <*> ib <*> ic <*> id <*> ie
    -- f :: a -> (b -> (c -> (d -> (e -> f))))
    -- f <$> ia :: IO (b -> (c -> (d -> (e -> f))))
    -- (f <$> ia) <*> ib :: IO (c -> (d -> (e -> f)))
    -- ((f <$> ia) <*> ib) <*> ic :: IO (d -> (e -> f))
    -- (((f <$> ia) <*> ib) <*> ic) <*> id :: IO (e -> f)
    -- ((((f <$> ia) <*> ib) <*> ic) <*> id) <*> ie :: IO f

    join2 :: IO (IO (IO a)) -> IO a
    join2 iiia = join (join iiia)          -- or: join2 = join . join

    (>>=) :: IO a -> (a -> IO b) -> IO b
    ia >>= f = join (f <$> ia)

### `do` notation

`do` notation is a syntactic sugar to combine actions.\
`do` notation is desugared to `(>>)` and `(>>=)` calls.

Example 1:

    sequence [] = pure []
    sequence (ia: ias) = do
        a <- ia
        as <- sequence ias
        return (a: as)

<!-- -->
    sequence [] = pure []
    sequence (ia: ias) =        -- do desugared
        ia >>= \a ->
        sequence ias >>= \as ->
        return (a: as)

Example 2:

    sequence_ [] = pure ()
    sequence_ (ia: ias) = do
        ia
        ias

<!-- -->
    sequence_ [] = pure ()
    sequence_ (ia: ias) =        -- do desugared
        ia >>
        ias

Example 3:

    getLine = do
        c <- getChar
        case c of
            '\n' -> pure []
            c -> do
                cs <- getLine
                return (c: cs)

<!-- -->
    getLine =                   -- do desugared
        getChar >>= \c ->
        case c of
            '\n' -> pure []
            c ->
                getLine >>= \cs ->
                return (c: cs)

## Generalizations of `IO` combinators

### Random value generation

`Gen` is a type constructor:

    Gen :: * -> *

`Gen a` is the type of random generators of `a`-typed values.

We say just generator instead of random generator.

Examples of types constructed with `Gen`, giving an element for each:

    -- Generates one of the given values.
    elements :: [a] -> Gen a

    -- Chooses one of the given generators, with a weighted random distribution.
    frequency :: [(Int, Gen a)] -> Gen a

    -- Generates a value that satisfies a predicate.
    suchThat :: Gen a -> (a -> Bool) -> Gen a

    -- Generates a random element with each combinator and collect their result in a list
    sequence :: [Gen a] -> Gen [a]

    -- Generates always the given element (not random)
    pure :: a -> Gen a

    -- Generates a generator randomly, then generates an element with it
    join :: Gen (Gen a) -> Gen a

Examples of generators constructed from smaller generators:

    vectorOf :: Int -> Gen a -> Gen [a]
    vectorOf n gen = sequence (replicate n gen)

    infiniteListOf :: Gen a -> Gen [a]
    infiniteListOf gen = sequence (repeat gen)

    -- Generates a non-empty list of random length. The maximum length is given explicitly.
    listOfSize :: Int -> Gen a -> Gen [a]
    listOfSize n gen = join (f <$> elements [0..n])       -- instance Functor Gen
      where
        f k = vectorOf k gen

You may noticed that there is `instance Functor Gen`.

#### Performing random generation

We can generate one random value with generate:

    generate :: Gen a -> IO a 

Example usage:

    Test.QuickCheck.Gen>  generate $ elements [True, False]
    False

For convenience, there is a `sample` function which can be used during
development:

    -- Generates some example values and prints them to stdout.
    sample :: Show a => Gen a -> IO () 

Example usage:

    Test.QuickCheck.Gen>  sample $ elements [True, False]
    True
    True
    True
    False
    True
    False
    True
    False
    False
    True
    False

<!-- -->
    Test.QuickCheck.Gen>  sample $ vectorOf 20 $ elements  " *"
    "  **  ****** *  *  *"
    "*   ***  **    *   *"
    "  **    ***** ****  "
    " *  *  *  *  *    * "
    "  *  *** **   **   *"
    " *****     **    *  "
    " * ****  ** *  *  * "
    " ** **  * * ** * ***"
    "****  *  * **  *****"
    " *      *  *** * ***"
    "***    **** * * ** *"

#### Basic combinators

There are elementary generators and a set of basic combinators with
which any other generators can be constructed.

The four most basic combinators are surprisingly similar to the
combinators of `IO` actions:

    pure   :: a             -> Gen a                   -- give back the given element, no choice

    (<$>)  :: (a -> b)      -> Gen a -> Gen b          -- apply a function on the result

    liftA2 :: (a -> b -> c) -> Gen a -> Gen b -> Gen c -- combine two generator result

    join   :: Gen (Gen a) -> Gen a                     -- flatten an generator-returning generator

Definitely, there is a structure here which is worth to be abstracted
out.

## Generic combinators for computations

In fact, there are several type classes based on the above functions,
each of them has its own merits:

    (a -> b) -> f a -> f b              | | | | | |Functor   |
    (a -> b -> c) -> f a -> f b -> f c  | | | | |Apply       |
    a -> f a                            | | | |Applicative   |
    f (f a) -> f a                      | | |Monad           -
    f a                                 | |MonadFail         |
    f a -> f a -> f a                   |MonadPlus           |Alternative

Let's look at them one-by-one.

### `Functor`

    class Functor f where
      fmap :: (a -> b) -> f a -> f b

      (<$) :: a        -> f b -> f a
      (<$) = fmap . const

<!-- -->
    fmap id == id
    fmap (g . h) == fmap g . fmap h

<!-- -->
    void :: Functor f => f a -> f () 
    void x = () <$ x

### `Applicative`

    class Functor f => Applicative f where
      pure  :: a -> f a
      infixl 4 <*>, *>, <*
      (<*>) :: f (a -> b) -> f a -> f b
     
      (*>) :: f a -> f b -> f b
      a1 *> a2 = (id <$ a1) <*> a2
     
      (<*) :: f a -> f b -> f a
      (<*) = liftA2 const

<!-- -->
    liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c

<!-- -->
    when :: Applicative f => Bool -> f () -> f () 

<!-- -->
    unless :: Applicative f => Bool -> f () -> f ()

<!-- -->
    sequenceA :: Monad m => [m a] -> m [a]

<!-- -->
      unit :: f ()
      (**) :: f a -> f b -> f (a,b)

    unit ** v â‰… v
    u ** unit â‰… u
    u ** (v ** w) â‰… (u ** v) ** w

### `Monad`

    class Applicative m => Monad m where
      (>>=)  :: m a -> (a -> m b) -> m b

      return :: a -> m a                    -- same as pure

      (>>)   :: m a -> m b -> m b
      m >> n = m >>= \_ -> n
     
      fail   :: String -> m a               -- will be moved to MonadFail

<!-- -->
    (=<<) :: Monad m => (a -> m b) -> m a -> m b        -- effectful fmap
    (=<<) = flip (>>=)

<!-- -->
    (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> a -> m c   -- effectful composition
    (f <=< g) a = f =<< g a

<!-- -->
    (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
    (>=>) = flip (<=<)

Monad laws:

         pure <=< f  =  f                   -- like       id . f = f
         f <=< pure  =  f                   -- like       f . id = f
    (f <=< g) <=< h  =  f <=< (g <=< h)     -- like  (f . g) . h = f . (g . h)

<!-- -->
    sequence :: Monad m => [m a] -> m [a]

<!-- -->
    replicateM :: Monad m => Int -> m a -> m [a]

#### `State` monad

The simplified interface of `State` monad:

    State :: * -> * -> *   -- (State Int Char) produces a Char with the help of an Int state

<!-- -->
    instance Monad (State s)        -- and also Functor, Applicative

<!-- -->
    state :: (s -> (a, s)) -> State s a
    runState :: State s a -> s -> (a, s)

Example usage:

    newId :: State Int Int
    newId = state $ \s -> (s+1, s+1)

    numberLine :: String -> State Int String
    numberLine s = do
        i <- newId
        pure $ show i ++ ". " ++ s

<!-- -->
    Main>  runState (mapM numberLine ["hello","world"]) 0
    (["1. hello","2. world"],2)

Useful functions:

    evalState :: State s a -> s -> a        -- the final state is not needed
    evalState m s = fst $ runState m s

<!-- -->
    execState :: State s a -> s -> s        -- only the final state is needed
    execState m s = snd $ runState m s

#### Implementation of `State`

    {-# language ViewPatterns #-}

    newtype State s a = State {runState :: s -> (a, s)}

    state :: (s -> (a, s)) -> State s a
    state = State

    instance Functor (State s) where
        -- fmap :: (a -> b) -> State s a -> State s b
        fmap f (State g) = State $ \(g -> (a, s)) -> (f a, s)

    instance Applicative (State s) where
        pure a = State $ \s -> (a, s)

        -- (<*>) :: State s (a -> b) -> State s a -> State s b
        State sf <*> State sa = State $ \(sf -> (f, sa -> (a, s))) -> (f a, s)

    instance Monad (State s) where
        return = pure

        -- (>>=) :: State s a -> (a -> State s b) -> State s b
        State f >>= g = State $ \(f -> (a, s)) -> runState (g a) s

#### `Maybe` monad

`Maybe a` can be seen as a computation which either succeeds and gives
an `x :: a` or fails.

Implementation:

    instance Functor Maybe where
        fmap f = maybe Nothing (Just . f)

    instance Applicative Maybe where
        pure = Maybe
        mf <*> ma = maybe Nothing (\f -> maybe Nothing (\a -> Just (f a))) mf

    instance Monad Maybe where
        ma >>= f = maybe Nothing f ma

Tests:

    (+1) <$> Nothing  ==  Nothing
    (+1) <$> Just 3  ==  Just 3
    Nothing   <*> Nothing  ==  Nothing
    Nothing   <*> Just 3   ==  Nothing
    Just (+1) <*> Nothing  ==  Nothing
    Just (+1) <*> Just 3   ==  Just 3
    Nothing  >>=  (\x -> if odd x then Nothing else Just (x + 1)) == Nothing
    Just 3   >>=  (\x -> if odd x then Nothing else Just (x + 1)) == Nothing
    Just 4   >>=  (\x -> if odd x then Nothing else Just (x + 1)) == Just 5

### `do` notation

### `Traversable`

Motivation: `fmap` is generalized `map`; traverse is generalized `fmap`:

    map      ::                                   (a ->   b) -> [a] ->    [b]
    fmap     ::                     Functor t  => (a ->   b) -> t a ->    t b
    traverse :: (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)

`fmap` maps a *pure* function, `traverse` maps an *effectful* function.

Usage example:

    -- generalized (zip [0..])
    assignIds :: Traversable t => t a -> t (Int, a)
    assignIds t = evalState (traverse assignId t) 0
      where
        assignId :: a -> State Int (Int, a)        -- the effect is (State Int)
        assignId x = do
            i <- newId
            pure (i, x)

    newId :: State Int Int
    newId x = state $ \s -> (s, s+1)

<!-- -->
    Main>  assignIds "hello"   -- same as  zip [0..] "hello"
    [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]

<!-- -->
    Main>  assignIds $ Map.fromList [("a",10),("b",4),("c",20)]
    fromList [("a",(0,10)),("b",(1,4)),("c",(2,20))]

### `Alternative`

    class Applicative f => Alternative f where
      empty :: f a
      (<|>) :: f a -> f a -> f a
     
      some :: f a -> f [a]
      many :: f a -> f [a]

    some v = (:) <$> v <*> many v
    many v = some v <|> pure []

<!-- -->
    empty <|> x = x
    x <|> empty = x
    (x <|> y) <|> z = x <|> (y <|> z)

<!-- -->
    guard :: Alternative f => Bool -> f ()

<!-- -->
    optional :: Alternative f => f a -> f (Maybe a)

## Monad transformers

Goal: mix different side effects

### `StateT s` -- adding state `s` to a computation

#### Interface

    StateT :: * -> (* -> *) -> (* -> *)

    instance Functor m => Functor (StateT s m)
    instance Monad m => Applicative (StateT s m)
    instance Monad m => Monad (StateT s m)

    StateT :: (s -> m (a, s)) -> StateT s m a
    runStateT :: StateT s m a -> s -> m (a, s)

#### Implementation

    newtype StateT s m a
        = StateT {runStateT :: s -> m (a, s)}

    instance Functor m => Functor (StateT s m) where
        -- fmap :: (a -> b) -> StateT s m a -> StateT s m b
        fmap f (StateT g) = StateT $ \s -> first f <$> g s

    instance Monad m => Applicative (StateT s m) where
        -- pure :: a -> StateT s m a
        pure a = StateT $ \s -> pure (a, s)

        -- (<*>) :: StateT s m (a -> b) -> StateT s m a -> StateT s m b
        StateT sf <*> StateT sa = StateT $ \s -> do
            (f, s) <- sf s
            (a, s) <- sa s
            pure (f a, s)

    instance Monad m => Monad (StateT s m) where
        -- (>>=) :: StateT s m a -> (a -> StateT s m b) -> StateT s m b
        StateT f >>= g = StateT $ \s -> do
            (a, s) <- f s
            runState (g a) s

#### Usage example

    newInt :: Monad m => StateT Int m Int
    newInt = StateT $ \s -> pure (s, s+1)

    lift :: Monad m => m a -> StateT s m a
    lift m = StateT $ \s -> do  a <- m
                                pure (a, s)

    numberLine :: String -> StateT Int IO String
    numberLine s = do
        c <- lift $ do
            putStr $ "Number this line? " ++ s ++ "\n(y/n) "
            c <- getChar
            putStr "\n"
            pure c
        case c of
            'y' -> do
                i <- newInt
                pure $ show i ++ ". " ++ s
            _ -> pure s

    test :: IO ()
    test = do
        (xs, _) <- flip runStateT 1 $ 
              traverse numberLine ["first","second","third"]
        traverse_ putStrLn xs

#### `State` defined with `StateT`

    type State s = StateT s Identity

The definition of the `Identity` monad:

    newtype Identity a = Identity {runIdentity :: a}

    instance Functor Identity where
        fmap f (Identity a) = Identity (f a)
    instance Applicative Identity where
        pure = Identity
        Identity f <*> Identity a = Identity (f a)
    instance Monad Identity where
        Identity a >>= g = g a

### `ExceptT e` -- add exception handling

Remark: The `Maybe` monad is isomorphic to `ExceptT () Identity`.

#### Interface

    ExceptT :: * -> (* -> *) -> (* -> *)

    ExceptT :: m (Either e a) -> ExceptT e m a
    runExceptT :: ExceptT e m a -> m (Either e a)

    instance Functor m => Functor (ExceptT e m)
    instance Monad m => Applicative (ExceptT e m)
    instance Monad m => Monad (ExceptT e m)

#### How to throw an error

    throwError :: Monad m => e -> ExceptT e m a
    throwError e = ExceptT $ pure $ Left e

The actual `throwError` is more polymorphic (in an ad-hoc way).

## Testing with `QuickCheck`

### Quickly check properties

    quickCheck :: Testable prop => prop -> IO ()

Examples:

    Test.QuickCheck>  quickCheck $ \a b c -> (a + b) + c == a + (b + c)
    +++ OK, passed 100 tests.

<!-- -->
    Test.QuickCheck>  quickCheck $ \a -> a == a + a
    *** Failed! Falsifiable (after 2 tests):                  
    1

The `Testable` type class has instances:

    instance Testable Bool
    instance (Arbitrary a, Show a, Testable prop) => Testable (a -> prop)

The `Arbitrary` class has instances:

    instance Arbitrary Bool
    instance Arbitrary Integer
    instance Arbitrary a => Arbitrary [a]
    instance (Arbitrary a, Arbitrary b) => Arbitrary (Either a b)
    instance (Arbitrary a, Arbitrary b) => Arbitrary (a, b)
    ...

### Changing generator behaviour

    Test.QuickCheck>  quickCheck $ \a b -> (a `div` b) * b + a `mod` b == a
    *** Failed! Exception: 'divide by zero' (after 1 test):
    0          -- a
    0          -- b

Fix:

    Test.QuickCheck>  quickCheck $ \a (NonZero b) -> (a `div` b) * b + a `mod` b == a
    +++ OK, passed 100 tests.

This works because

    newtype NonZero a = NonZero {getNonZero :: a}

    instance (Num a, Eq a, Arbitrary a) => Arbitrary (NonZero a) where
      arbitrary = NonZero <$> (arbitrary `suchThat` (/= 0))

Other modifier usage examples:

    Test.QuickCheck>  quickCheck $ \(NonNegative a) (Positive b) -> a `div` b == a `quot` b
    +++ OK, passed 100 tests.

<!-- -->
    Test.QuickCheck>  quickCheck $ \(NonEmpty xs) -> xs == head xs: tail xs
    +++ OK, passed 100 tests.

<!-- -->
    Test.QuickCheck Data.List>  quickCheck $ \(Ordered xs) -> sort xs == xs
    +++ OK, passed 100 tests.

### Run more tests

    Test.QuickCheck Data.List>  quickCheck $ \a -> a < 0.9 || a > 1
    +++ OK, passed 100 tests.
    Test.QuickCheck Data.List>  quickCheck $ withMaxSuccess 10000 $ \a -> a < 0.9 || a > 1
    *** Failed! Falsifiable (after 307 tests):  
    0.9784714901633009

### Testing higher order functions

    >  quickCheck $ \(Fn (f :: Int -> Int)) (Fn (g :: Int -> Int)) x -> (f . g) x == (g . f) x
    *** Failed! Falsifiable (after 3 tests and 20 shrinks):    
    {_->0}
    {0->1, _->0}
    0

### Custom data types

Any data type is supported if it has an `Arbitrary` instance.

The `Arbitrary` class provides a random generator for each instance:

    class Arbitrary a where
      arbitrary :: Gen a

### Random value generation

    data Gen a

    instance Monad Gen a        -- implies Functor and Applicative

Generator combinators:

    elements :: [a] -> Gen a 

    choose :: Random a => (a, a) -> Gen a  -- for ranges of Char, Double, Float, Int, ...

    frequency :: [(Int, Gen a)] -> Gen a 

    listOf :: Gen a -> Gen [a]

    listOf1 :: Gen a -> Gen [a] 

    suchThat :: Gen a -> (a -> Bool) -> Gen a 

Running a generator:

    generate :: Gen a -> IO a 

For debugging:

    sample :: Show a => Gen a -> IO ()

Example:

    Test.QuickCheck>  sample (arbitrary :: Gen (Either Bool Int))
    Left False
    Right (-1)
    Left False
    Left True
    Left False
    Left True
    Right (-11)
    Left False
    Right 11
    Left False
    Right 7

### Sized random value generation

Size of randomly generated values matters:

-   `quickCheck` tries smaller values first and larger values later
-   For recursive or deeply nested data structures, smaller and smaller
    values should be generated with increasing recursion levels,
    otherwise the generated value could blow up.

The meaning of size depends on the actual data structure:

-   length for lists
-   maximum value for `Integer`
-   ...

Size control can be achieved by the following two functions:

    scale :: (Int -> Int) -> Gen a -> Gen a 

    sized :: (Int -> Gen a) -> Gen a 

`sized` is used in `Arbitrary` instances.\
For example, the `Arbitrary` instance for lists is implemented with
`listOf` which is implemented with `sized`:

    listOf :: Gen a -> Gen [a]
    listOf gen = sized $ \n ->
      do k <- choose (0,n)
         vectorOf k gen

We can observe the increasing list sizes with sample too:

    Test.QuickCheck>  sample (arbitrary :: Gen [Int])
    []
    []
    [-1,0]
    [0,-6]
    [-6]
    [6,-6,-9,-5,-2,-6,-9,4,-3]
    [1,-8,11,7,5,-11,-9,6]
    [1,-8,-5,12,-8,0,-8,-4,-9,-4,-4,3,-9]
    [0,0,-1,6,-11,-9,-9,-14,0,-16,-11,-15,15,-4,14]
    [-4,15]
    [20,-12,-4,-11,-18,17,-13,-10,2,-12]

`scale` can be used directy during debugging random generators:

    Test.QuickCheck>  sample $ scale (*2) (arbitrary :: Gen [Int])
    []
    [3,0,-1]
    [5,2,4,-8,7,-2,4]
    [1,12,-8,-11,12,-12,2,-10,0]
    [2,-4,15,14,2,-10]
    [8,-10]
    [20,14,-10,-24,3,-17,21,-14,-4,-14,-22,8,-7,-20,-3,-18]
    [16,-18,13,-5]
    [17,-14,0,-11,16,15,3,27,-17,-2,5,27,15,9,23,27,10,18,13,21,-25,4,-16,27,8,-8,-30,13,3]
    [15,-8,-23]
    [3,-26,-30,-23,-14,19,-25,18,-19,34,-12,-5,26]

`scale` is used implicitly by `mapSize`:

    Test.QuickCheck>  quickCheck $ \a -> a == take 100 a
    +++ OK, passed 100 tests.                                   -- wrong!!!

<!-- -->
    Test.QuickCheck>  quickCheck $ mapSize (*10) $ \a -> a == take 100 a
    *** Failed! Falsifiable (after 13 tests and 2 shrinks):      
    [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()
    ,(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()
    ,(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()
    ,(),(),(),(),(),(),(),()]

Pandoc uses `resize`, which is the same as `scale` with a constant size:

    resize :: Int -> Gen a -> Gen a 
    resize n = scale (const n)

## JSON conversion

``` {.bash}
$ echo 'Hello *World*!' | pandoc --to json
{"blocks":[{"t":"Para","c":[{"t":"Str","c":"Hello"},{"t":"Space"},{"t":"Emph","c":[{"t":"Str"
,"c":"World"}]},{"t":"Str","c":"!"}]}],"pandoc-api-version":[1,17,3,1],"meta":{}}
```

<!-- -->
``` {.bash}
$ echo 'Hello *World*!' | pandoc --to json | pandoc --from json
<p>Hello <em>World</em>!</p>
```

JSON conversion scheme:

                        decode
            <-----------------------------
            parseJSON
    Pandoc  <--------    Value    <-------   ByteString
            -------->             ------->  
             toJSON
            ----------------------------->
                        encode

JSON conversion API:

    module Data.Aeson where

    ...

    encode :: ToJSON a => a -> ByteString
    decode :: FromJSON a => ByteString -> Maybe a 

    class ToJSON a where
        toJSON :: a -> Value
        ...

    class FromJSON a where
        parseJSON :: Value -> Parser a
        ...

    -- JSON "syntax tree" in Haskell
    data Value = Object !Object
               | Array !Array
               | String !Text
               | Number !Scientific
               | Bool !Bool
               | Null

    type Object = HashMap Text Value

    type Array = Vector Value

    data Parser a 

    instance Monad Parser

`ToJSON` instances in `Text.Pandoc.Definition`:

    instance ToJSON Inline where
      toJSON (Str s) = tagged "Str" s
      toJSON (Emph ils) = tagged "Emph" ils
      toJSON (Strong ils) = tagged "Strong" ils
      toJSON (Strikeout ils) = tagged "Strikeout" ils
      ...
      toJSON Space = taggedNoContent "Space"
      ...

    tagged :: ToJSON a => [Char] -> a -> Value
    tagged x y = object [ "t" .= x, "c" .= y ]

    taggedNoContent :: [Char] -> Value
    taggedNoContent x = object [ "t" .= x ]

    object :: [Pair] -> Value  -- imported from Data.Aeson

    type Pair = (Text, Value)  -- imported from Data.Aeson

    (.=) :: ToJSON v => Text -> v -> Pair   -- imported from Data.Aeson, specialized type

`FromJSON` instances in `Text.Pandoc.Definition`:

    instance FromJSON Inline where
      parseJSON (Object v) = do
        t <- v .: "t"
        case t of
          "Str"         -> Str <$> v .: "c"
          "Emph"        -> Emph <$> v .: "c"
          "Strong"      -> Strong <$> v .: "c"
          "Strikeout"   -> Strikeout <$> v .: "c"
          ...
          "Space"       -> return Space
          ...

    (.:) :: FromJSON a => Object -> Text -> Parser a   -- imported from Data.Aeson

## Running tests

    -- pandoc-types/test/test-pandoc-types.hs

    ...

    prop_roundtrip :: Pandoc -> Bool
    prop_roundtrip doc = case decode $ encode doc :: (Maybe Pandoc) of
      Just doc' -> doc == doc'
      _ -> False

    ...

    tests :: [Test]
    tests =
      [ ...
      , testGroup "JSON"
        [ testGroup "encoding/decoding properties"
          [ testProperty "round-trip" prop_roundtrip
          ]
        , ...
        ]
      ]

    main :: IO ()
    main = defaultMain tests

How to run the tests:

``` {.bash}
pandoc-types$ cabal install --enable-tests
...
/pandoc-types$ cabal test
Preprocessing library for pandoc-types-1.17.3..
Building library for pandoc-types-1.17.3..
Preprocessing test suite 'test-pandoc-types' for pandoc-types-1.17.3..
Building test suite 'test-pandoc-types' for pandoc-types-1.17.3..
Running 1 test suites...
Test suite test-pandoc-types: RUNNING...
Test suite test-pandoc-types: PASS
Test suite logged to: dist/test/pandoc-types-1.17.3-test-pandoc-types.log
1 of 1 test suites (1 of 1 test cases) passed.
$
```

<!-- -->
<!-- -->
<!-- -->
    choose :: Random a => (a,a) -> Gen a

    suchThat :: Gen a -> (a -> Bool) -> Gen a

    -- | Generates one of the given values. The input list must be non-empty.
    elements :: [a] -> Gen a
    elements [] = error "QuickCheck.elements used with empty list"
    elements xs = (xs !!) `fmap` choose (0, length xs - 1)

    -- | Chooses one of the given generators, with a weighted random distribution.
    -- The input list must be non-empty.
    frequency :: [(Int, Gen a)] -> Gen a
    frequency [] = error "QuickCheck.frequency used with empty list"
    frequency xs0 = choose (1, tot) >>= (`pick` xs0)
     where
      tot = sum (map fst xs0)

      pick n ((k,x):xs)
        | n <= k    = x
        | otherwise = pick (n-k) xs
      pick _ _  = error "QuickCheck.pick used with empty list"


    -- | Generates a list of random length. The maximum length depends on the
    -- size parameter.
    listOf :: Gen a -> Gen [a]
    listOf gen = sized $ \n ->
      do k <- choose (0,n)
         vectorOf k gen

    -- | Generates a non-empty list of random length. The maximum length
    -- depends on the size parameter.
    listOf1 :: Gen a -> Gen [a]
    listOf1 gen = sized $ \n ->
      do k <- choose (1,1 `max` n)
         vectorOf k gen

## Generic programming

TODO

## Date and Time handling

-   `UTCTime`, `TimeZone`, -- `ZonedTime`

## Words

-   `Word8`

## Bits

# Pandoc's source code

## Web locations

The most recent *released* source code and API of Pandoc packages can be
found at HackageDB, the Haskell community's central package archive of
open source software. The source code of the development versions is on
GitHub.

The two main Pandoc related packages and their main contents are the
following:

-   **pandoc-type** [on
    HackageDB](https://hackage.haskell.org/package/pandoc-types) and [on
    GitHub](https://github.com/jgm/pandoc-types)
    -   [inner document data structure
        definition](https://hackage.haskell.org/package/pandoc-types/docs/Text-Pandoc-Definition.html)
        (1 `.hs` module, \~24KB)
    -   basic operations on the inner representation (5 `.hs` module,
        \~49KB)
    -   basic tests on the inner representation
-   **pandoc** [on
    HackageDB](https://hackage.haskell.org/package/pandoc) and [on
    GitHub](https://github.com/jgm/pandoc)
    -   [pandoc API](https://hackage.haskell.org/package/pandoc#modules)
        implementation
        -   infrastructure (45 `.hs` modules, \~495KB)
        -   source code of readers in the `Readers` directory (45 `.hs`
            modules, \~918KB)
        -   source code of writers in the `Writers` directory (36 `.hs`
            modules, \~885KB)
    -   pandoc executable source code (1 `.hs` module, \~1.3KB)
    -   static data files
        -   templates for each output format (39 files, \~69Kb)
    -   test framework
        -   source code (46 `.hs` files, \~336KB)
        -   tests (576 files, \~4762KB)

## Overview of Pandoc's software architecture

Pandoc has a modular design: it has a reader for each input format,
which parses the input document and produces an inner representation of
the document (like an abstract syntax tree or AST), and a writer for
each output format, which converts this inner representation into the
target.

The inner representation can be observed via the `native` output format:

``` {.bash}
$ echo 'Hello, *World*!' | pandoc --to native
[Para [Str "Hello,",Space,Emph [Str "World"],Str "!"]]
```

The inner representation can be serialized in `JSON` format:

``` {.bash}
$ echo 'Hello, *World*!' | pandoc --to json
{"blocks":[{"t":"Para","c":[{"t":"Str","c":"Hello,"},{"t":"Space"}
,{"t":"Emph","c":[{"t":"Str","c":"World"}]},{"t":"Str","c":"!"}]}]
,"pandoc-api-version":[1,17,3,1],"meta":{}}
```

The `json` format has a fast de-serializer. An example of
de-serialization:

``` {.bash}
$ echo 'Hello, *World*!' | pandoc --to json | pandoc --from json
<p>Hello, <em>World</em>!</p>
```

One can run filters on the JSON format. The filter can be implemented in
Haskell or in any other languages.

Readers and writers have *extensions* which can be turned on and off
individually.

Each output format has a default *template* file which is used to
produce standalone documents in the given format. The default template
is customizable with variables like `title`, `date`, `lang`, ... or one
can replace the default template by a custom template file.

    ________                 _____________                 _____________                 ______
    input(s)  ---reader--->  native format  ---filter--->  native format  ---writer--->  output
              customized by                 freely given                  customized by
              - language                                                  - language
                - extensions                                                - extensions
                                                                            - template file
                                                                              - variables

Main components of Pandoc and related main data structures are shown on
\ref{fig:data}. The next sections discuss the components one-by-one.

![Dependencies between main components and their data
structures\label{fig:data}](Data.pdf)

## Document representation

![Dependencies between data types for document
representation](Pandoc.pdf)

A Pandoc document has two main parts: metavalues and contents (which is
a list of `Block`s):

    data Pandoc = Pandoc Meta [Block]

The content is built up with `Inline` and `Block` elements:

    data Inline      -- content placed inline, i.e. without line breaks before and after it
    data Block       -- content placed with line breaks around it

### Inline elements

#### Basic inline elements

    data Inline
        = Str String            -- ^ Text (string)
        | Space                 -- ^ Inter-word space
        | ...

The most basic inline element is a string of characters:

    Str "Hello" :: Inline

Inter-word spaces are represented by `Space`:

    Space :: Inline

For example, "Hello world!" is represented as list of inline elements:

    [Str "Hello", Space, Str "world!"] :: [Inline]

#### Non-canonical representations

There are several representations of the same text, but only one of them
is *canonical*.

The general rules for canonicity (in order of importance):

1.  **Use the most specific constructor**

    For example, `Space` should be used instead of `Str " "`.

2.  **Use less constructors**

    For example, `[Str "world!"]` should be used instead of
    `[Str "world", Str "!"]`.

Examples:

    [Str "Hello", Space, Str "world!"] :: [Inline]          -- canonical

<!-- -->
    [Str "Hello world!"] :: [Inline]                        -- non-canonical (space inside Str)

<!-- -->
    [Str "Hello", Space, Str "world", Str "!"] :: [Inline]  -- non-canonical (Str next to Str)

#### Spaces

    data Inline
        = ...
        | Space                 -- ^ Inter-word space
        | SoftBreak             -- ^ Soft line break
        | LineBreak             -- ^ Hard line break
        | ...

A *soft line break* is rendered as a space or as a newline depending on
the page width.

Spaces cannot be next to each other:

    [Space, SoftBreak]      -- non-canonical (space next to space)

Non-breaking space `'\160'` is stored inside `Str` elements.

#### Basic markups

    data Inline
        = ...
        | Emph [Inline]             -- ^ Emphasized text
        | Strong [Inline]           -- ^ Strongly emphasized text
        | Strikeout [Inline]        -- ^ Strikeout text
        | Superscript [Inline]      -- ^ Superscripted text
        | Subscript [Inline]        -- ^ Subscripted text
        | SmallCaps [Inline]        -- ^ Small caps text
        | Quoted QuoteType [Inline] -- ^ Quoted text
        | ...

The type of quotations:

    data QuoteType = SingleQuote | DoubleQuote

The general rules of canonicity apply:

    [Emph [Str "a"], Emph [Str "b"]]             -- non canonical (Emph next to Emph)

<!-- -->
    [Emph [Str "a", Emph [Str "b"]]]             -- non canonical (Emph inside Emph)

<!-- -->
    [Emph [Str "a", Strikeout [Emph [Str "b"]]]] -- non canonical (Emph deeply inside Emph)

<!-- -->
    [Strong [Str "a", Emph [Str "b"]]]           -- non canonical (Strong shadows Emph)

#### Links and images

Only links to actual images are stored in the document, so the
representation of images is similar to the representation of links:

    data Inline
        = ...
        | Link  Attr [Inline] Target -- ^ Hyperlink: alt text (list of inlines), target
        | Image Attr [Inline] Target -- ^ Image:  alt text (list of inlines), target
        | ...

`Target` is a synonym for (URL, title) pairs:

    type Target = (String, String)  --  (URL, title)

Example image:

    Image nullAttr [Str "dog_cannot_be_shown"] ("http://...", "pitbull")

Attributes are discussed later.

#### Notes

Footnotes are stored inline at the place where they are referred in the
text. They are moved to the end of the text when the text is rendered.

    data Inline
        = ...
        | Note [Block]          -- ^ Footnote or endnote
        | ...

#### Other inline elements

Other inline elements (native spans, code blocks, raw elements, embedded
LaTeX and citations) are discussed later.

### Block elements

#### Paragraphs

    data Block
        = Plain [Inline]        -- ^ Plain text, not a paragraph
        | Para [Inline]         -- ^ Paragraph
        | LineBlock [[Inline]]  -- ^ Multiple non-breaking lines
        | ...

`Plain xs` is rendered as a plain block of text.

`Para xs` is rendered as a paragraph (with `<p>` tags in HTML).

`LineBlock xss` is rendered as non-breaking lines with line breaks
between them (like a verse).

#### Block quotes

Block quotes are usually rendered with more indentation.

    data Block
        = ...
        | BlockQuote [Block]    -- ^ Block quote (list of blocks)
        | ...

#### Headers

Headers with level 1, 2, 3, 4, 5, 6 are supported in HTML output.

    data Block
        = ...
        | Header Int Attr [Inline] -- ^ Header - level (integer) and text (inlines)
        | ...

Attributes are discussed later.

#### Horizontal rule

Rendered as a horizontal rule.

    data Block
        = ...
        | HorizontalRule        -- ^ Horizontal rule
        | ...

#### Other block elements

TODO: document `Null`

    data Block
        = ...
        | Null                  -- ^ Nothing
        | ...

Other block elements (native divs, code fragments, raw blocks, lists and
tables) are discussed later.

### Attributes

There are 3 different kind of attributes:

-   identifiers

    Identifiers are rendered as HTML identifiers in HTML output.

    Identifiers are used for labels and link anchors in a few other
    writers.

-   classes

    The typical use case of classes is to style HTML output with CSS.

    Other use cases:

    -   Headers with the class `unnumbered` will not be numbered.
    -   Code blocks supports the `numberLines` and `lineAnchors` classes
        (see later).
    -   Code blocks and code fragments use classes like `haskell` to set
        the language (for syntax highlighting).
    -   `smallcaps` class is used to write text in small caps
    -   Native divs use the `column` class to set multi-column layout.

-   key-value pairs

    Use cases:

    -   `lang` and `dir` keys are used to set the language and direction
        (`rtl` or `ltr`) of text.
    -   `startFrom` key is used to set the start number if code block
        lines are numbered.
    -   Native divs with `column` class use the `with` key for
        specifying the number of columns.
    -   The `width` and `height` keys on images are treated specially.

`Attr` is a triple of an identifier, classes and key-value pairs. The
`""` string is used if there is no identifier attribute.

    -- | Attributes: identifier, classes, key-value pairs
    type Attr = (String, [String], [(String, String)])

`nullAttr` is the default:

    nullAttr :: Attr
    nullAttr = ("",[],[])

#### Native spans and divs

Native spans and divs are used to set attributes of any inlines or list
of blocks.

    data Inline
        = ...
        | Span Attr [Inline]    -- ^ Generic inline container with attributes
        | ...

<!-- -->
    data Block
        = ...
        | Div Attr [Block]      -- ^ Generic block container with attributes
        | ...

### Source code in documents

Inline code fragments:

    data Inline
        = ...
        | Code Attr String      -- ^ Inline code (literal)
        | ...

Code blocks:

    data Block
        = ...
        | CodeBlock Attr String -- ^ Code block (literal) with attributes
        | ...

The following attributes are treated specially in writers:

-   Classes like `haskell` are used to set the language (for syntax
    highlighting).
-   The `numberLines` (or `number-lines`) class will cause the lines of
    the code block to be numbered, starting with 1 or the value of the
    `startFrom` key.
    -   `startFrom` key is used to set the start number
-   The `lineAnchors` (or `line-anchors`) class will cause the lines of
    code blocks to be clickable anchors in HTML output.

### Raw elements

Raw inlines and raw blocks is treated as raw content with the designated
format. TODO

    data Inline
        = ...
        | RawInline Format String -- ^ Raw inline
        | ...

<!-- -->
    data Block
        = ...
        | RawBlock Format String -- ^ Raw block
        | ...

<!-- -->
    -- | Formats for raw blocks
    newtype Format = Format String

Example formats: TODO

### Walking documents

[`Text.Pandoc.Walk`](hackage.haskell.org/package/pandoc-types/docs/Text-Pandoc-Walk.html)
defines

    class Walkable a b where
        walk  ::            (a ->   a) -> b ->   b    -- pure walk
        walkM :: Monad m => (a -> m a) -> b -> m b    -- effectful walk
        query :: Monoid c => (a -> c) -> b -> c 

There are lots of `Walkable` instances, notable ones are:

    instance Walkable Block  Pandoc
    instance Walkable Inline Pandoc

Usage examples:

    allCaps :: Pandoc -> Pandoc     -- capitalize all string
    allCaps = walk f
      where
        f :: Inline -> Inline
        f (Str xs) = Str $ map toUpper xs
        f x = x

<!-- -->
    every2ndCaps :: Pandoc -> Pandoc     -- capitalize every 2nd inline element
    every2ndCaps p = evalState (walkM f p) False
      where
        f :: Inline -> State Bool Inline
        f (Str xs) = do
            b <- state $ \b -> (b, not b)
            pure $ Str $ if b then map toUpper xs else xs
        f x = pure x

<!-- -->
    getLinks :: Pandoc -> [Target]
    getLinks = query f
      where
        f :: Inline -> [Target]
        f (Link _ _ t) = [t]
        f _ = []

### Pandoc filters

Program which normalizes a pandoc file:

    import qualified Data.Text.IO as Text
    import Text.Pandoc

    main :: IO ()
    main = do
        text <- Text.readFile "example.md"
        p <- runIOorExplode $ readMarkdown (def {readerExtensions = pandocExtensions}) text
        text' <- runIOorExplode $ writeMarkdown (def {writerExtensions = pandocExtensions}) p
        Text.writeFile "exampleOut.md" text'

It is easy to modify this program to transform the document, for example
capitalize headers in it.

Another option is to use *pandoc filters*.

[`Text.Pandoc.JSON`](hackage.haskell.org/package/pandoc-types/docs/Text-Pandoc-JSON.html)
defines

    class ToJSONFilter a where
        toJSONFilter :: a -> IO () 

Notable instances are

    instance Walkable a Pandoc => ToJSONFilter (a -> a)
    instance Walkable a Pandoc => ToJSONFilter (a -> [a])

so `toJSONFilter` can be specialized as, for example

    toJSONFilter :: (Inline -> Inline) -> IO ()
    -- produces a program which walks a pandoc JSON representation with the given function

Example usage:

    ------------------------- contents of capitalize.hs
    #!/usr/bin/env runghc
    import Data.Char
    import Text.Pandoc
    import Text.Pandoc.JSON

    main :: IO ()
    main = toJSONFilter f
      where
        f :: Inline -> Inline
        f (Str xs) = Str $ map toUpper xs
        f x = x

This "filter" can be used with pandoc like this:

``` {.bash}
> pandoc --filter ./capitalize.hs
```

## Logging

### `PandocError`

### `LogMessage`

### `Verbosity`

## Actions

### `CommonState` data type

### `PandocMonad` type class

#### MediaBag

#### MimeType

### `PandocIO`

### `PandocPure`

## Readers

## Writers

## Command line interface

![Main data flow](App.pdf)

## Additional features

### Language support

### Filters

### Lists

    data Block
        = ...
        | OrderedList ListAttributes [[Block]] -- ^ Ordered list (attributes
                                -- and a list of items, each a list of blocks)
        | BulletList [[Block]]  -- ^ Bullet list (list of items, each
                                -- a list of blocks)
        | DefinitionList [([Inline],[[Block]])]  -- ^ Definition list
                                -- Each list item is a pair consisting of a
                                -- term (a list of inlines) and one or more
                                -- definitions (each a list of blocks)
        | ...


    -- | List attributes.
    type ListAttributes = (Int, ListNumberStyle, ListNumberDelim)

    -- | Style of list numbers.
    data ListNumberStyle = DefaultStyle
                         | Example
                         | Decimal
                         | LowerRoman
                         | UpperRoman
                         | LowerAlpha
                         | UpperAlpha deriving (Eq, Ord, Show, Read, Typeable, Data, Generic)

    -- | Delimiter of list numbers.
    data ListNumberDelim = DefaultDelim
                         | Period
                         | OneParen
                         | TwoParens deriving (Eq, Ord, Show, Read, Typeable, Data, Generic)

### Tables

    data Block
        = ...
        | Table [Inline] [Alignment] [Double] [TableCell] [[TableCell]]  -- ^ Table,
                                -- with caption, column alignments (required),
                                -- relative column widths (0 = default),
                                -- column headers (each a list of blocks), and
                                -- rows (each a list of lists of blocks)
        | ...

### Math support

    data Inline
        = ...
        | Math MathType String  -- ^ TeX math (literal)
        | ...

### Citations

    data Inline
        = ...
        | Cite [Citation]  [Inline] -- ^ Citation (list of inlines)
        | ...

### Support for slide shows

## Developer tools

### Test suit

### Benchmarks

### Packaging

### Documentation

### Version control
